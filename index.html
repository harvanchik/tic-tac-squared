<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tic Tac Squared</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <style>
      :root {
        --x-color: #ff4757;
        --o-color: #1e90ff;
        --bg-color: #2f3542;
        --board-bg: #57606f;
        --highlight: rgba(255, 255, 255, 0.1);
        --text-light: #f1f2f6;
        --modal-bg: rgba(47, 53, 66, 0.95);
      }

      body {
        margin: 0;
        padding: 0;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-light);
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
      }

      header {
        text-align: center;
        margin: 20px 0;
        width: 100%;
        position: relative;
      }

      h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        color: white;
      }

      .game-info {
        display: flex;
        justify-content: space-between;
        width: 500px;
        margin: 0 auto 20px;
        font-size: 1.2rem;
        font-weight: bold;
      }

      .player {
        padding: 10px 20px;
        border-radius: 5px;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .player.active {
        background-color: var(--highlight);
      }

      .player-x {
        color: var(--x-color);
      }

      .player-o {
        color: var(--o-color);
      }

      .super-board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        gap: 10px;
        width: 500px;
        height: 500px;
        margin: 0 auto;
        position: relative;
      }

      .board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        gap: 5px;
        background-color: var(--board-bg);
        border-radius: 8px;
        padding: 5px;
        position: relative;
        overflow: hidden;
      }

      .board.active {
        box-shadow: 0 0 0 3px var(--text-light);
        animation: pulse 1.5s infinite;
      }

      .board.won-x {
        background-color: rgba(255, 71, 87, 0.2);
        border: 3px solid var(--x-color);
      }

      .board.won-o {
        background-color: rgba(30, 144, 255, 0.2);
        border: 3px solid var(--o-color);
      }

      .board.tie {
        background-color: rgba(113, 128, 147, 0.5);
        border: 3px solid var(--text-light);
      }

      .cell {
        background-color: var(--bg-color);
        border-radius: 4px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 24px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
        position: relative;
        z-index: 2;
      }

      .cell:hover:not(.occupied) {
        background-color: var(--highlight);
      }

      .cell.x {
        color: var(--x-color);
      }

      .cell.o {
        color: var(--o-color);
      }

      .cell.last-move {
        position: relative;
      }

      .cell.last-move::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: currentColor;
        opacity: 0.15;
        pointer-events: none;
        border-radius: 4px;
      }

      .winning-line {
        position: absolute;
        background-color: rgba(255, 255, 255, 0.8);
        z-index: 5;
        transform-origin: 0 0;
      }

      .controls {
        margin-top: 30px;
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        justify-content: center;
      }

      button {
        padding: 10px 20px;
        background-color: var(--board-bg);
        color: var(--text-light);
        border: none;
        border-radius: 5px;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      .ai-thinking {
        margin-top: 20px;
        font-style: italic;
        opacity: 0;
        transition: opacity 0.3s;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .ai-thinking.show {
        opacity: 1;
      }

      .game-over {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s;
      }

      .game-over.show {
        opacity: 1;
        pointer-events: all;
      }

      .game-over-message {
        font-size: 3rem;
        font-weight: bold;
        margin-bottom: 20px;
        text-align: center;
      }

      .game-over-message.x {
        color: var(--x-color);
      }

      .game-over-message.o {
        color: var(--o-color);
      }

      .game-over-message.tie {
        color: var(--text-light);
      }

      .game-over-buttons {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        justify-content: center;
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 3px var(--text-light);
        }
        50% {
          box-shadow: 0 0 0 6px var(--text-light);
        }
        100% {
          box-shadow: 0 0 0 3px var(--text-light);
        }
      }

      .settings-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--modal-bg);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 200;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s;
      }

      .settings-modal.show {
        opacity: 1;
        pointer-events: all;
      }

      .settings-content {
        background-color: var(--board-bg);
        padding: 30px;
        border-radius: 10px;
        width: 400px;
        max-width: 90%;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      }

      .settings-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .settings-title {
        font-size: 1.5rem;
        margin: 0;
      }

      .setting-group {
        margin-bottom: 20px;
      }

      .setting-label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
      }

      .setting-option {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }

      .setting-option input {
        margin-right: 10px;
      }

      .color-picker {
        display: flex;
        gap: 15px;
        margin-top: 15px;
      }

      .color-option {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 10px;
      }

      .color-box {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid transparent;
        transition: transform 0.2s;
      }

      .color-box.selected {
        border-color: var(--text-light);
        transform: scale(1.1);
      }

      .settings-footer {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 30px;
      }

      .coin-flip-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 300;
      }

      .coin-flip-content {
        background-color: var(--board-bg);
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        max-width: 90%;
      }

      .coin {
        width: 100px;
        height: 100px;
        margin: 20px auto;
        position: relative;
        transform-style: preserve-3d;
        transition: transform 0.1s;
      }

      .coin.flipping {
        animation: flip-coin 1.5s ease-out forwards;
      }

      .coin-side {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        backface-visibility: hidden;
        font-size: 2.5rem;
        font-weight: bold;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      }

      .coin-side.heads {
        background: linear-gradient(45deg, #ffd700, #ffcc00);
        border: 4px solid #e6b800;
        color: var(--x-color);
        z-index: 2;
      }

      .coin-side.tails {
        background: linear-gradient(45deg, #ffd700, #ffcc00);
        border: 4px solid #e6b800;
        color: var(--o-color);
        transform: rotateY(180deg);
      }

      input[type='color']::-moz-color-swatch {
        border: none;
      }

      input[type='color']::-webkit-color-swatch-wrapper {
        padding: 0;
        border-radius: 0;
      }

      input[type='color']::-webkit-color-swatch {
        border: none;
      }

      @keyframes flip-coin {
        0% {
          transform: rotateY(0) rotateX(0);
        }
        20% {
          transform: rotateY(180deg) rotateX(720deg);
        }
        40% {
          transform: rotateY(360deg) rotateX(1440deg);
        }
        60% {
          transform: rotateY(540deg) rotateX(2160deg);
        }
        80% {
          transform: rotateY(720deg) rotateX(2880deg);
        }
        100% {
          transform: rotateY(900deg) rotateX(3600deg);
        }
      }

      .color-picker-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 400;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s;
      }

      .color-picker-modal.show {
        opacity: 1;
        pointer-events: all;
      }

      .color-picker-content {
        background-color: var(--board-bg);
        padding: 20px;
        border-radius: 10px;
        text-align: center;
      }

      .color-picker-input {
        width: 100%;
        margin: 15px 0;
      }

      .color-picker-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 15px;
      }

      @media (max-width: 600px) {
        .super-board {
          width: 90vw;
          height: 90vw;
        }

        .game-info {
          width: 90vw;
          font-size: 1rem;
        }

        .controls {
          width: 90vw;
        }

        .game-over-message {
          font-size: 2rem;
        }

        .game-over-buttons {
          flex-direction: column;
          width: 80%;
        }

        .game-over-buttons button {
          width: 100%;
        }

        .player {
          padding: 8px 12px;
          font-size: 0.9rem;
        }

        h1 {
          font-size: 2rem;
        }
      }

      .how-to-play-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--modal-bg);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 200;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s;
      }

      .how-to-play-modal.show {
        opacity: 1;
        pointer-events: all;
      }

      .how-to-play-content {
        background-color: var(--board-bg);
        padding: 30px;
        border-radius: 10px;
        width: 600px;
        max-width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      }

      .how-to-play-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .how-to-play-title {
        font-size: 1.5rem;
        margin: 0;
      }

      .how-to-play-body {
        margin-bottom: 20px;
      }

      .how-to-play-body h3 {
        margin-top: 16px;
        margin-bottom: 8px;
        color: var(--text-light);
      }

      .how-to-play-body p,
      .how-to-play-body li {
        margin-bottom: 8px;
        line-height: 1.5;
      }

      .how-to-play-footer {
        display: flex;
        justify-content: center;
      }

      /* Add transparent border to modal buttons */
      .settings-modal button,
      .how-to-play-modal button,
      .color-picker-modal button,
      .game-over button {
        border: 1px solid rgba(255, 255, 255, 0.3);
        transition: all 0.3s;
      }

      .settings-modal button:hover,
      .how-to-play-modal button:hover,
      .color-picker-modal button:hover,
      .game-over button:hover {
        border-color: rgba(255, 255, 255, 0.8);
      }

      /* Add two-column layout for settings */
      .settings-columns {
        display: flex;
        gap: 20px;
      }

      .settings-column {
        flex: 1;
      }

      /* Make sure AI difficulty group doesn't increase modal height */
      #aiDifficultyGroup {
        display: none;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Tic Tac Squared</h1>
      <div class="game-info">
        <div class="player player-x active">
          <i class="fas fa-user"></i> <i class="fas fa-times fa-lg"></i>
        </div>
        <div id="aiThinking" class="ai-thinking">
          AI thinking... <i class="fas fa-cog fa-spin"></i>
        </div>
        <div class="player player-o">
          <i class="fas fa-robot"></i> <i class="far fa-circle"></i>
        </div>
      </div>
    </header>

    <div id="superBoard" class="super-board"></div>

    <div class="settings-modal" id="settingsModal">
      <div class="settings-content">
        <div class="settings-header">
          <h3 class="settings-title">Game Settings</h3>
        </div>

        <div class="settings-columns">
          <div class="settings-column">
            <div class="setting-group">
              <label class="setting-label">Game Mode:</label>
              <div class="setting-option">
                <input
                  type="radio"
                  id="humanVsHuman"
                  name="gameMode"
                  value="human" />
                <label for="humanVsHuman">Human vs Human</label>
              </div>
              <div class="setting-option">
                <input
                  type="radio"
                  id="humanVsAI"
                  name="gameMode"
                  value="ai"
                  checked />
                <label for="humanVsAI">Human vs AI</label>
              </div>
            </div>
          </div>

          <div class="settings-column">
            <div class="setting-group" id="aiDifficultyGroup">
              <label class="setting-label">AI Difficulty:</label>
              <div class="setting-option">
                <input
                  type="radio"
                  id="easyAI"
                  name="difficulty"
                  value="easy" />
                <label for="easyAI">Easy</label>
              </div>
              <div class="setting-option">
                <input
                  type="radio"
                  id="mediumAI"
                  name="difficulty"
                  value="medium"
                  checked />
                <label for="mediumAI">Medium</label>
              </div>
              <div class="setting-option">
                <input
                  type="radio"
                  id="hardAI"
                  name="difficulty"
                  value="hard" />
                <label for="hardAI">Hard</label>
              </div>
            </div>
          </div>
        </div>

        <div class="setting-group">
          <label class="setting-label">Rules:</label>
          <div class="setting-option">
            <input
              type="radio"
              id="standardRules"
              name="rules"
              value="standard"
              checked />
            <label for="standardRules"
              >Standard (next board determined by last move)</label
            >
          </div>
          <div class="setting-option">
            <input type="radio" id="freeRules" name="rules" value="free" />
            <label for="freeRules"
              >Free Play (move in any board at any time)</label
            >
          </div>
        </div>

        <div class="setting-group">
          <label class="setting-label">Player Colors:</label>
          <div class="color-picker">
            <div class="color-option">
              <label>X Color</label>
              <input
                type="color"
                id="xColorPicker"
                class="color-box"
                data-player="x"
                value="#ff4757"
                style="
                  background-color: transparent;
                  border: 0;
                  width: 30px;
                  height: 30px;
                  border-radius: 50%;
                  cursor: pointer;
                  appearance: none;
                  -webkit-appearance: none;
                  padding: 0;
                  overflow: hidden;
                " />
            </div>
            <div class="color-option">
              <label>O Color</label>
              <input
                type="color"
                id="oColorPicker"
                class="color-box"
                data-player="o"
                value="#1e90ff"
                style="
                  background-color: transparent;
                  border: 0;
                  width: 30px;
                  height: 30px;
                  border-radius: 50%;
                  cursor: pointer;
                  appearance: none;
                  -webkit-appearance: none;
                  padding: 0;
                  overflow: hidden;
                " />
            </div>
          </div>
        </div>

        <div class="settings-footer">
          <button id="saveSettings"><i class="fas fa-save"></i> Save</button>
          <button id="cancelSettings"><i class="fas fa-times"></i> Exit</button>
        </div>
      </div>
    </div>

    <div class="coin-flip-modal" id="coinFlipModal">
      <div class="coin-flip-content">
        <h2>Flip a Coin</h2>
        <p>Determining who goes first...</p>
        <div class="coin" id="coin">
          <div class="coin-side heads">
            <i class="fas fa-times fa-2x"></i>
          </div>
          <div class="coin-side tails">
            <i class="far fa-circle fa-2x"></i>
          </div>
        </div>
        <div id="coinResult"></div>
      </div>
    </div>

    <div class="how-to-play-modal" id="howToPlayModal">
      <div class="how-to-play-content">
        <div class="how-to-play-header">
          <h3 class="how-to-play-title">How to Play</h3>
        </div>

        <div class="how-to-play-body">
          <h3>Basic Rules</h3>
          <ul>
            <li>Players take turns marking spaces with X or O.</li>
            <li>
              Win a small board by getting three of your marks in a row
              (horizontally, vertically, or diagonally).
            </li>
            <li>
              Win the game by winning three small boards in a row on the super
              board.
            </li>
          </ul>

          <h3>Board Selection Rules</h3>
          <p>
            <strong>Standard Rules:</strong> Your move sends your opponent to
            the corresponding board. For example, if you play in the top-right
            cell of any board, your opponent must play in the top-right board.
          </p>
          <p>
            <strong>Free Play:</strong> Players can play in any non-completed
            board on their turn.
          </p>

          <h3>Special Situations</h3>
          <ul>
            <li>
              If you're sent to a board that's already won or tied, you can play
              in any available board.
            </li>
            <li>
              A tied board (filled with no winner) doesn't count for either
              player.
            </li>
          </ul>
        </div>

        <div class="how-to-play-footer">
          <button id="closeHowToPlayBtn">
            <i class="fas fa-check"></i> Got It
          </button>
        </div>
      </div>
    </div>

    <div class="color-picker-modal" id="colorPickerModal">
      <div class="color-picker-content">
        <h3 id="colorPickerTitle">Select Color</h3>
        <input type="color" id="colorPickerInput" class="color-picker-input" />
        <div class="color-picker-buttons">
          <button id="confirmColorBtn">
            <i class="fas fa-check"></i> Confirm
          </button>
          <button id="cancelColorBtn">
            <i class="fas fa-times"></i> Cancel
          </button>
        </div>
      </div>
    </div>

    <div class="controls">
      <button id="howToPlayBtn">
        <i class="fas fa-question-circle"></i> How to Play
      </button>
      <button id="settingsBtn"><i class="fas fa-cog"></i> Settings</button>
      <button id="newGameBtn">
        <i class="fas fa-plus-circle"></i> New Game
      </button>
    </div>

    <div class="game-over" id="gameOver">
      <div id="gameOverMessage" class="game-over-message"></div>
      <div class="game-over-buttons">
        <button id="playAgainBtn">
          <i class="fas fa-sync-alt"></i> Play Again
        </button>
        <button id="viewBoardBtn"><i class="fas fa-eye"></i> View Board</button>
      </div>
    </div>

    <script>
      // Game elements
      const superBoard = document.getElementById('superBoard');
      const playerXDisplay = document.querySelector('.player-x');
      const playerODisplay = document.querySelector('.player-o');
      const aiThinking = document.getElementById('aiThinking');
      const howToPlayBtn = document.getElementById('howToPlayBtn');
      const newGameBtn = document.getElementById('newGameBtn');
      const gameOver = document.getElementById('gameOver');
      const gameOverMessage = document.getElementById('gameOverMessage');
      const playAgainBtn = document.getElementById('playAgainBtn');
      const viewBoardBtn = document.getElementById('viewBoardBtn');
      const settingsBtn = document.getElementById('settingsBtn');
      const settingsModal = document.getElementById('settingsModal');
      const saveSettings = document.getElementById('saveSettings');
      const cancelSettings = document.getElementById('cancelSettings');
      const humanVsHuman = document.getElementById('humanVsHuman');
      const humanVsAI = document.getElementById('humanVsAI');
      const aiDifficultyGroup = document.getElementById('aiDifficultyGroup');
      const coinFlipModal = document.getElementById('coinFlipModal');
      const coin = document.getElementById('coin');
      const coinResult = document.getElementById('coinResult');
      const colorPickerModal = document.getElementById('colorPickerModal');
      const colorPickerTitle = document.getElementById('colorPickerTitle');
      const colorPickerInput = document.getElementById('colorPickerInput');
      const confirmColorBtn = document.getElementById('confirmColorBtn');
      const cancelColorBtn = document.getElementById('cancelColorBtn');
      const xColorPicker = document.getElementById('xColorPicker');
      const oColorPicker = document.getElementById('oColorPicker');
      const howToPlayModal = document.getElementById('howToPlayModal');
      const closeHowToPlayBtn = document.getElementById('closeHowToPlayBtn');

      // Game state
      let currentPlayer = ''; // x or o (empty before coin flip)
      let activeBoard = null; // which board is active (null means any board)
      let boards = Array(9)
        .fill()
        .map(() => Array(9).fill(''));
      let boardWinners = Array(9).fill(''); // 'x', 'o', 'tie', or ''
      let gameWinner = '';
      let gameActive = false; // starts false until coin flip
      let winningCombination = null;
      // Add lastMove tracking
      let lastMove = { boardIndex: -1, cellIndex: -1, player: '' };

      // Game settings
      let gameSettings = {
        gameMode: 'ai', // 'human' or 'ai'
        rules: 'standard', // 'standard' or 'free'
        xColor: '#ff4757',
        oColor: '#1e90ff',
        difficulty: 'medium', // 'easy', 'medium', 'hard'
      };

      // Color picker state
      let currentColorPicker = null; // 'x' or 'o' when picking color

      // Helper function to convert hex to rgba
      function hexToRGBA(hex, alpha) {
        let r = parseInt(hex.slice(1, 3), 16);
        let g = parseInt(hex.slice(3, 5), 16);
        let b = parseInt(hex.slice(5, 7), 16);

        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      // Update colors based on game settings
      function updateColors() {
        // Update CSS variables
        document.documentElement.style.setProperty(
          '--x-color',
          gameSettings.xColor,
        );
        document.documentElement.style.setProperty(
          '--o-color',
          gameSettings.oColor,
        );

        // Update player displays
        playerXDisplay.style.color = gameSettings.xColor;
        playerODisplay.style.color = gameSettings.oColor;

        // Update color pickers if they exist
        if (xColorPicker) {
          xColorPicker.value = gameSettings.xColor;
          xColorPicker.style.backgroundColor = gameSettings.xColor;
        }
        if (oColorPicker) {
          oColorPicker.value = gameSettings.oColor;
          oColorPicker.style.backgroundColor = gameSettings.oColor;
        }

        // Update existing board outlines for won boards
        document.querySelectorAll('.board.won-x').forEach(board => {
          board.style.borderColor = gameSettings.xColor;
          board.style.backgroundColor = hexToRGBA(gameSettings.xColor, 0.2);
        });

        document.querySelectorAll('.board.won-o').forEach(board => {
          board.style.borderColor = gameSettings.oColor;
          board.style.backgroundColor = hexToRGBA(gameSettings.oColor, 0.2);
        });

        // Update winning lines
        document.querySelectorAll('.winning-line').forEach(line => {
          const board = line.closest('.board');
          if (board) {
            // Line is in a specific board
            const boardIndex = parseInt(board.dataset.index);
            if (boardWinners[boardIndex] === 'x') {
              line.style.backgroundColor = gameSettings.xColor;
            } else if (boardWinners[boardIndex] === 'o') {
              line.style.backgroundColor = gameSettings.oColor;
            }
          } else {
            // Line is on the super board
            if (gameWinner === 'x') {
              line.style.backgroundColor = gameSettings.xColor;
            } else if (gameWinner === 'o') {
              line.style.backgroundColor = gameSettings.oColor;
            }
          }
        });
      }

      // Save game state to localStorage
      function saveGameState() {
        const gameState = {
          currentPlayer,
          activeBoard,
          boards,
          boardWinners,
          gameWinner,
          gameActive,
          winningCombination,
          gameSettings,
          lastMove, // Save the last move information
        };

        localStorage.setItem('ticTacSquaredState', JSON.stringify(gameState));
      }

      // Update the loadGameState function
      function loadGameState() {
        try {
          const savedState = localStorage.getItem('ticTacSquaredState');
          if (!savedState) return false;

          const gameState = JSON.parse(savedState);

          // Restore game settings
          gameSettings = gameState.gameSettings;

          // Update UI before restoring other state variables
          if (gameSettings.gameMode === 'ai') {
            playerODisplay.innerHTML =
              '<i class="fas fa-robot"></i> <i class="far fa-circle"></i>';
          } else {
            playerODisplay.innerHTML =
              '<i class="fas fa-user"></i> <i class="far fa-circle"></i>';
          }

          // Restore game state variables
          currentPlayer = gameState.currentPlayer;
          activeBoard = gameState.activeBoard;
          boards = gameState.boards;
          boardWinners = gameState.boardWinners;
          gameWinner = gameState.gameWinner;
          gameActive = gameState.gameActive;
          winningCombination = gameState.winningCombination;

          // Restore last move information
          if (gameState.lastMove) {
            lastMove = gameState.lastMove;
          } else {
            // For backwards compatibility with older saved games
            lastMove = { boardIndex: -1, cellIndex: -1, player: '' };
          }

          // Recreate the board UI
          recreateGameUI();

          // Hide the coin flip modal when loading a saved game
          coinFlipModal.style.display = 'none';

          return true;
        } catch (error) {
          console.error('Error loading saved game:', error);
          return false;
        }
      }

      // Clear saved game state
      function clearSavedGameState() {
        localStorage.removeItem('ticTacSquaredState');
      }

      // Recreate the board UI from the current game state
      function recreateGameUI() {
        // Create all boards and cells with current state
        for (let i = 0; i < 9; i++) {
          const board = document.createElement('div');
          board.className = 'board';
          board.dataset.index = i;

          // Create cells for this board first
          for (let j = 0; j < 9; j++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.board = i;
            cell.dataset.cell = j;
            cell.addEventListener('click', handleCellClick);

            // Add cell content if occupied
            if (boards[i][j] === 'x') {
              cell.classList.add('x', 'occupied');
              cell.innerHTML = '<i class="fas fa-times fa-lg"></i>';
            } else if (boards[i][j] === 'o') {
              cell.classList.add('o', 'occupied');
              cell.innerHTML = '<i class="far fa-circle"></i>';
            }

            board.appendChild(cell);
          }

          // Now that cells exist, add board winner class and fade cells if applicable
          if (boardWinners[i] === 'x') {
            board.classList.add('won-x');
            board.style.borderColor = gameSettings.xColor;
            board.style.backgroundColor = hexToRGBA(gameSettings.xColor, 0.2);

            // Fade all cells in this board
            const cells = board.querySelectorAll('.cell');
            cells.forEach(cell => {
              cell.style.opacity = '0.6';
            });
          } else if (boardWinners[i] === 'o') {
            board.classList.add('won-o');
            board.style.borderColor = gameSettings.oColor;
            board.style.backgroundColor = hexToRGBA(gameSettings.oColor, 0.2);

            // Fade all cells in this board
            const cells = board.querySelectorAll('.cell');
            cells.forEach(cell => {
              cell.style.opacity = '0.6';
            });
          } else if (boardWinners[i] === 'tie') {
            board.classList.add('tie');

            // Fade all cells in this board
            const cells = board.querySelectorAll('.cell');
            cells.forEach(cell => {
              cell.style.opacity = '0.6';
            });
          }

          superBoard.appendChild(board);
        }

        // Update player display
        playerXDisplay.classList.toggle('active', currentPlayer === 'x');
        playerODisplay.classList.toggle('active', currentPlayer === 'o');

        // Update colors based on settings
        updateColors();

        // Update active boards highlighting
        updateActiveBoards();

        // If game is over, show game over screen
        if (gameWinner !== '') {
          if (gameWinner === 'x') {
            gameOverMessage.textContent =
              gameSettings.gameMode === 'ai' ? 'You Win!' : 'Player X Wins!';
            gameOverMessage.className = 'game-over-message x';
          } else if (gameWinner === 'o') {
            gameOverMessage.textContent =
              gameSettings.gameMode === 'ai' ? 'AI Wins!' : 'Player O Wins!';
            gameOverMessage.className = 'game-over-message o';
          } else {
            gameOverMessage.textContent = 'Game Tied!';
            gameOverMessage.className = 'game-over-message tie';
          }

          // Draw super board winning line if there's a winner
          if (winningCombination && gameWinner !== 'tie') {
            drawSuperWinningLine(winningCombination);
          }

          gameOver.classList.add('show');
        }

        // Redraw winning lines for boards
        for (let i = 0; i < 9; i++) {
          if (boardWinners[i] === 'x' || boardWinners[i] === 'o') {
            const winningCombo = findWinningCombo(i);
            if (winningCombo) drawWinningLine(i, winningCombo);
          }
        }

        // Find and highlight the last move if the game is in progress
        if (gameActive) {
          findAndHighlightLastMove();
        }
      }

      // Find winning combo for a board (for UI recreation)
      function findWinningCombo(boardIndex) {
        const board = boards[boardIndex];
        const winningCombos = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8], // rows
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8], // columns
          [0, 4, 8],
          [2, 4, 6], // diagonals
        ];

        for (const combo of winningCombos) {
          const [a, b, c] = combo;
          if (board[a] && board[a] === board[b] && board[a] === board[c]) {
            return combo;
          }
        }

        return null;
      }

      // Update initGame to clear saved state and start a new game
      function initGame() {
        // Clear saved game state
        clearSavedGameState();

        // Clear the super board
        superBoard.innerHTML = '';

        // Clear any existing winning lines
        document.querySelectorAll('.winning-line').forEach(el => el.remove());

        // Reset game state
        currentPlayer = '';
        activeBoard = null;
        boards = Array(9)
          .fill()
          .map(() => Array(9).fill(''));
        boardWinners = Array(9).fill('');
        gameWinner = '';
        gameActive = false;
        winningCombination = null;
        lastMove = { boardIndex: -1, cellIndex: -1, player: '' };

        // Update player display
        playerXDisplay.classList.remove('active');
        playerODisplay.classList.remove('active');

        // Update player icons based on game mode
        if (gameSettings.gameMode === 'ai') {
          playerODisplay.innerHTML =
            '<i class="fas fa-robot"></i> <i class="far fa-circle"></i>';
        } else {
          playerODisplay.innerHTML =
            '<i class="fas fa-user"></i> <i class="far fa-circle"></i>';
        }

        // Hide game over screen
        gameOver.classList.remove('show');
        aiThinking.classList.remove('show');

        // Create all boards and cells
        for (let i = 0; i < 9; i++) {
          const board = document.createElement('div');
          board.className = 'board';
          board.dataset.index = i;

          // Create cells for this board
          for (let j = 0; j < 9; j++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.board = i;
            cell.dataset.cell = j;
            cell.addEventListener('click', handleCellClick);
            board.appendChild(cell);
          }

          superBoard.appendChild(board);
        }

        // Update colors based on settings
        updateColors();

        // Show coin flip modal and start the flip
        coinFlipModal.style.display = 'flex';
        flipCoin();
      }

      // Handle cell click event
      function handleCellClick(event) {
        // Only proceed if game is active
        if (!gameActive) return;

        // Prevent human from making a move on AI's turn
        if (currentPlayer === 'o' && gameSettings.gameMode === 'ai') return;

        const cell = event.currentTarget;
        const boardIndex = parseInt(cell.dataset.board);
        const cellIndex = parseInt(cell.dataset.cell);

        // Check if cell is already occupied
        if (boards[boardIndex][cellIndex] !== '') return;

        // Check if this board is active
        const board = cell.closest('.board');
        if (!board.classList.contains('active')) return;

        // Make the move
        makeMove(boardIndex, cellIndex, currentPlayer);

        // If game is still active and it's AI's turn, make AI move
        if (
          gameActive &&
          currentPlayer === 'o' &&
          gameSettings.gameMode === 'ai'
        ) {
          setTimeout(function () {
            aiMakeMove();
          }, 500);
        }
      }

      // Update makeMove to track lastMove
      function makeMove(boardIndex, cellIndex, player) {
        // Update game state
        boards[boardIndex][cellIndex] = player;

        // Remove last-move class from any previous cells
        document.querySelectorAll('.cell.last-move').forEach(cell => {
          cell.classList.remove('last-move');
        });

        // Update lastMove tracking
        lastMove = { boardIndex, cellIndex, player };

        // Update UI
        const cell = document.querySelector(
          `.cell[data-board="${boardIndex}"][data-cell="${cellIndex}"]`,
        );
        cell.classList.add(player, 'occupied', 'last-move');
        cell.innerHTML =
          player === 'x'
            ? '<i class="fas fa-times fa-lg"></i>'
            : '<i class="far fa-circle"></i>';

        // Check if this board has a winner
        checkBoardWinner(boardIndex);

        // Switch active board to the cell index that was just clicked
        // Unless that board is already won or free play is enabled
        if (gameSettings.rules === 'standard') {
          activeBoard = boardWinners[cellIndex] === '' ? cellIndex : null;
        } else {
          activeBoard = null;
        }

        // Update active boards highlighting
        updateActiveBoards();

        // Switch player
        currentPlayer = currentPlayer === 'x' ? 'o' : 'x';

        // Update player display
        playerXDisplay.classList.toggle('active');
        playerODisplay.classList.toggle('active');

        // Check if game has a winner
        checkGameWinner();

        // Save game state
        saveGameState();
      }

      // Add a wrapper function to initialize the game
      function initializeGame() {
        // Set up modal outside click listeners
        setupModalOutsideClickListeners();

        // Try to load saved game state first
        if (loadGameState()) {
          console.log('Loaded saved game state');
          return;
        }

        // If no saved state or loading fails, start a new game with coin flip
        initGame();
      }

      // Update endGame to save the final state
      function endGame() {
        gameActive = false;

        // Show game over message
        if (gameWinner === 'x') {
          gameOverMessage.textContent =
            gameSettings.gameMode === 'ai' ? 'You Win!' : 'Player X Wins!';
          gameOverMessage.className = 'game-over-message x';
        } else if (gameWinner === 'o') {
          gameOverMessage.textContent =
            gameSettings.gameMode === 'ai' ? 'AI Wins!' : 'Player O Wins!';
          gameOverMessage.className = 'game-over-message o';
        } else {
          gameOverMessage.textContent = 'Game Tied!';
          gameOverMessage.className = 'game-over-message tie';
        }

        // Draw super board winning line if there's a winner
        if (winningCombination) {
          drawSuperWinningLine(winningCombination);
        }

        // Save final game state
        saveGameState();

        gameOver.classList.add('show');
      }

      // Check if a board has a winner
      function checkBoardWinner(boardIndex) {
        const board = boards[boardIndex];
        const winningCombos = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8], // rows
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8], // columns
          [0, 4, 8],
          [2, 4, 6], // diagonals
        ];

        // Check for winner
        for (const combo of winningCombos) {
          const [a, b, c] = combo;
          if (board[a] && board[a] === board[b] && board[a] === board[c]) {
            boardWinners[boardIndex] = board[a];
            updateBoardUI(boardIndex, combo);
            return;
          }
        }

        // Check for tie
        if (!board.includes('')) {
          boardWinners[boardIndex] = 'tie';
          updateBoardUI(boardIndex);
        }
      }

      // Update board UI when it's won
      function updateBoardUI(boardIndex, winningCombo = null) {
        const board = document.querySelector(
          `.board[data-index="${boardIndex}"]`,
        );

        if (boardWinners[boardIndex] === 'x') {
          board.classList.add('won-x');
          board.style.borderColor = gameSettings.xColor;
          // Set background color with opacity
          board.style.backgroundColor = hexToRGBA(gameSettings.xColor, 0.2);

          // Fade all X's and O's in this board
          board.querySelectorAll('.cell').forEach(cell => {
            cell.style.opacity = '0.6';
          });
        } else if (boardWinners[boardIndex] === 'o') {
          board.classList.add('won-o');
          board.style.borderColor = gameSettings.oColor;
          // Set background color with opacity
          board.style.backgroundColor = hexToRGBA(gameSettings.oColor, 0.2);

          // Fade all X's and O's in this board
          board.querySelectorAll('.cell').forEach(cell => {
            cell.style.opacity = '0.6';
          });
        } else if (boardWinners[boardIndex] === 'tie') {
          board.classList.add('tie');

          // Fade all X's and O's in this board
          board.querySelectorAll('.cell').forEach(cell => {
            cell.style.opacity = '0.6';
          });
        }

        // If there's a winning combo, draw the line
        if (winningCombo) {
          drawWinningLine(boardIndex, winningCombo);
        }
      }

      // Draw winning line on a board - fixed positioning for better centering
      function drawWinningLine(boardIndex, combo) {
        const board = document.querySelector(
          `.board[data-index="${boardIndex}"]`,
        );
        const boardRect = board.getBoundingClientRect();
        const cellSize = boardRect.width / 3;

        // Get positions of the winning cells
        const [a, b, c] = combo;
        const aCol = a % 3;
        const aRow = Math.floor(a / 3);
        const cCol = c % 3;
        const cRow = Math.floor(c / 3);

        // Calculate start and end points
        let startX, startY, endX, endY;

        // For rows - ensure horizontal lines are centered vertically in each row
        if (aRow === cRow) {
          startX = cellSize * 0.1; // Small offset from left edge

          // Calculate the exact center of the row
          startY = aRow * cellSize + cellSize / 2;

          endX = boardRect.width - cellSize * 0.1; // Small offset from right edge
          endY = startY;
        }
        // For columns - ensure vertical lines are centered horizontally in each column
        else if (aCol === cCol) {
          // Calculate the exact center of the column
          startX = aCol * cellSize + cellSize / 2;

          startY = cellSize * 0.1; // Small offset from top edge
          endX = startX;
          endY = boardRect.height - cellSize * 0.1; // Small offset from bottom edge
        }
        // For diagonals - keep the current implementation as requested
        else {
          if (a === 0 || c === 0) {
            // Top-left to bottom-right diagonal
            startX = cellSize * 0.1 + 2;
            startY = cellSize * 0.1 - 0; // Shifted up at start
            endX = boardRect.width - cellSize + 395 * 0.1 + 1;
            endY = boardRect.height - cellSize + 395 * 0.1 - 1; // Shifted up more at end
          } else {
            // Top-right to bottom-left diagonal
            startX = boardRect.width - cellSize * 0.1 - 8;
            startY = cellSize * 0.1 + 0; // Shifted up at start
            endX = cellSize * 0.1 + 2;
            endY = boardRect.height - cellSize * 0.1 - 10; // Shifted up more at end
          }
        }

        // Create the line element
        const line = document.createElement('div');
        line.className = 'winning-line';
        line.style.width = `${Math.sqrt(
          Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2),
        )}px`;
        line.style.height = '4px'; // line thickness
        line.style.left = `${startX}px`;
        line.style.top = `${startY}px`;
        line.style.transform = `rotate(${Math.atan2(endY - startY, endX - startX)}rad)`;
        line.style.transformOrigin = '0 50%'; // Center the line vertically
        line.style.backgroundColor =
          boardWinners[boardIndex] === 'x'
            ? gameSettings.xColor
            : gameSettings.oColor;

        board.appendChild(line);
      }

      // Check if the game has a winner
      function checkGameWinner() {
        const winningCombos = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8], // rows
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8], // columns
          [0, 4, 8],
          [2, 4, 6], // diagonals
        ];

        // Check for winner
        for (const combo of winningCombos) {
          const [a, b, c] = combo;
          if (
            boardWinners[a] &&
            boardWinners[a] === boardWinners[b] &&
            boardWinners[a] === boardWinners[c]
          ) {
            gameWinner = boardWinners[a];
            winningCombination = combo;
            endGame();
            return;
          }
        }

        // Check for tie
        if (!boardWinners.includes('')) {
          gameWinner = 'tie';
          endGame();
        }
      }

      // End the game
      function endGame() {
        gameActive = false;

        // Show game over message
        if (gameWinner === 'x') {
          gameOverMessage.textContent =
            gameSettings.gameMode === 'ai' ? 'You Win!' : 'Player X Wins!';
          gameOverMessage.className = 'game-over-message x';
        } else if (gameWinner === 'o') {
          gameOverMessage.textContent =
            gameSettings.gameMode === 'ai' ? 'AI Wins!' : 'Player O Wins!';
          gameOverMessage.className = 'game-over-message o';
        } else {
          gameOverMessage.textContent = 'Game Tied!';
          gameOverMessage.className = 'game-over-message tie';
        }

        // Draw super board winning line if there's a winner
        if (winningCombination) {
          drawSuperWinningLine(winningCombination);
        }

        // Save final game state
        saveGameState();

        gameOver.classList.add('show');
      }

      // Draw winning line on the super board
      function drawSuperWinningLine(combo) {
        const superBoardRect = superBoard.getBoundingClientRect();
        const boardSize = superBoardRect.width / 3;

        // Get positions of the winning boards
        const [a, b, c] = combo;
        const aCol = a % 3;
        const aRow = Math.floor(a / 3);
        const cCol = c % 3;
        const cRow = Math.floor(c / 3);

        // Calculate start and end points
        let startX, startY, endX, endY;

        // For rows
        if (aRow === cRow) {
          startX = 5; // Small offset from edge
          startY = (aRow + 0.5) * boardSize;
          endX = superBoardRect.width - 5; // Small offset from edge
          endY = startY;
        }
        // For columns
        else if (aCol === cCol) {
          startX = (aCol + 0.5) * boardSize;
          startY = 5; // Small offset from edge
          endX = startX;
          endY = superBoardRect.height - 5; // Small offset from edge
        }
        // For diagonals
        else {
          if (a === 0 || c === 0) {
            // Top-left to bottom-right
            startX = 5;
            startY = 5;
            endX = superBoardRect.width - 5;
            endY = superBoardRect.height - 5;
          } else {
            // Top-right to bottom-left
            startX = superBoardRect.width - 5;
            startY = 5;
            endX = 5;
            endY = superBoardRect.height - 5;
          }
        }

        // Create the line element
        const line = document.createElement('div');
        line.className = 'winning-line';
        line.style.width = `${Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2))}px`;
        line.style.height = '6px';
        line.style.left = `${startX}px`;
        line.style.top = `${startY}px`;
        line.style.transform = `rotate(${Math.atan2(endY - startY, endX - startX)}rad)`;
        line.style.backgroundColor =
          gameWinner === 'x' ? gameSettings.xColor : gameSettings.oColor;

        superBoard.appendChild(line);
      }

      // Update which boards are active
      function updateActiveBoards() {
        // Remove active class from all boards
        document.querySelectorAll('.board').forEach(board => {
          board.classList.remove('active');
        });

        // If game is over, no active boards
        if (!gameActive) return;

        // If no specific board is active (start of game or previous move sent to won board)
        if (activeBoard === null) {
          // All non-won boards are active
          document.querySelectorAll('.board').forEach((board, index) => {
            if (boardWinners[index] === '') {
              board.classList.add('active');
            }
          });
        } else {
          // Only the specified board is active (if it's not already won)
          if (boardWinners[activeBoard] === '') {
            document
              .querySelector(`.board[data-index="${activeBoard}"]`)
              .classList.add('active');
          } else {
            // If the target board is already won, any non-won board is active
            activeBoard = null;
            updateActiveBoards();
          }
        }
      }

      // AI makes a move
      function aiMakeMove() {
        // Show thinking indicator
        aiThinking.classList.add('show');

        // Simulate thinking delay
        setTimeout(
          () => {
            let boardIndex, cellIndex;

            // If a specific board is active, play there
            if (activeBoard !== null && boardWinners[activeBoard] === '') {
              boardIndex = activeBoard;
              cellIndex = findBestMove(boardIndex);
            } else {
              // Find the best move across all available boards
              const availableBoards = [];
              for (let i = 0; i < 9; i++) {
                if (boardWinners[i] === '') {
                  availableBoards.push(i);
                }
              }

              // If no boards available (shouldn't happen as game would be over)
              if (availableBoards.length === 0) return;

              // Try to find a winning move or block opponent's winning move
              let foundMove = false;

              // First, check if AI can win the game by winning a board
              if (gameSettings.difficulty !== 'easy') {
                for (const b of availableBoards) {
                  const tempBoard = [...boards[b]];
                  for (let c = 0; c < 9; c++) {
                    if (tempBoard[c] === '') {
                      tempBoard[c] = 'o';
                      if (checkTempBoardWinner(tempBoard) === 'o') {
                        boardIndex = b;
                        cellIndex = c;
                        foundMove = true;
                        break;
                      }
                      tempBoard[c] = '';
                    }
                  }
                  if (foundMove) break;
                }
              }

              // If not, check if player can win a board and block them
              if (!foundMove && gameSettings.difficulty !== 'easy') {
                for (const b of availableBoards) {
                  const tempBoard = [...boards[b]];
                  for (let c = 0; c < 9; c++) {
                    if (tempBoard[c] === '') {
                      tempBoard[c] = 'x';
                      if (checkTempBoardWinner(tempBoard) === 'x') {
                        boardIndex = b;
                        cellIndex = c;
                        foundMove = true;
                        break;
                      }
                      tempBoard[c] = '';
                    }
                  }
                  if (foundMove) break;
                }
              }

              // If no immediate win or block, find the best move
              if (!foundMove) {
                if (gameSettings.difficulty === 'easy') {
                  // Choose a random available board and cell
                  boardIndex =
                    availableBoards[
                      Math.floor(Math.random() * availableBoards.length)
                    ];
                  const availableCells = [];
                  for (let i = 0; i < 9; i++) {
                    if (boards[boardIndex][i] === '') {
                      availableCells.push(i);
                    }
                  }
                  cellIndex =
                    availableCells[
                      Math.floor(Math.random() * availableCells.length)
                    ];
                } else {
                  // Try to find a board where AI can win
                  if (gameSettings.difficulty === 'hard') {
                    for (const b of availableBoards) {
                      const tempBoard = [...boards[b]];
                      for (let c = 0; c < 9; c++) {
                        if (tempBoard[c] === '') {
                          tempBoard[c] = 'o';
                          if (checkTempBoardWinner(tempBoard) === 'o') {
                            boardIndex = b;
                            cellIndex = c;
                            foundMove = true;
                            break;
                          }
                          tempBoard[c] = '';
                        }
                      }
                      if (foundMove) break;
                    }
                  }

                  // If no winning move, find the best available move
                  if (!foundMove) {
                    // Choose a random available board
                    boardIndex =
                      availableBoards[
                        Math.floor(Math.random() * availableBoards.length)
                      ];
                    cellIndex = findBestMove(boardIndex);
                  }
                }
              }
            }

            // Make the move
            makeMove(boardIndex, cellIndex, 'o');

            // Save game state
            saveGameState();

            // Hide thinking indicator
            aiThinking.classList.remove('show');
          },
          gameSettings.difficulty === 'easy' ? 300 : 800,
        ); // AI thinking delay
      }

      // Find the best move in a specific board
      function findBestMove(boardIndex) {
        const board = boards[boardIndex];
        const availableCells = [];

        // Get all available cells
        for (let i = 0; i < 9; i++) {
          if (board[i] === '') {
            availableCells.push(i);
          }
        }

        // If center is available, take it
        if (board[4] === '') return 4;

        // If opponent has two in a row, block them
        const winningCombos = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8], // rows
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8], // columns
          [0, 4, 8],
          [2, 4, 6], // diagonals
        ];

        for (const combo of winningCombos) {
          const [a, b, c] = combo;
          // Check if player has two in a row and one empty
          if (
            (board[a] === 'x' && board[b] === 'x' && board[c] === '') ||
            (board[a] === 'x' && board[c] === 'x' && board[b] === '') ||
            (board[b] === 'x' && board[c] === 'x' && board[a] === '')
          ) {
            // Return the empty spot
            if (board[a] === '') return a;
            if (board[b] === '') return b;
            if (board[c] === '') return c;
          }
        }

        // Take a corner if available
        const corners = [0, 2, 6, 8];
        const availableCorners = corners.filter(corner => board[corner] === '');
        if (availableCorners.length > 0) {
          return availableCorners[
            Math.floor(Math.random() * availableCorners.length)
          ];
        }

        // Take any available edge
        const edges = [1, 3, 5, 7];
        const availableEdges = edges.filter(edge => board[edge] === '');
        if (availableEdges.length > 0) {
          return availableEdges[
            Math.floor(Math.random() * availableEdges.length)
          ];
        }

        // Fallback - should never happen as we check for tie before
        return availableCells[0];
      }

      // Check if a temporary board has a winner
      function checkTempBoardWinner(board) {
        const winningCombos = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8], // rows
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8], // columns
          [0, 4, 8],
          [2, 4, 6], // diagonals
        ];

        for (const combo of winningCombos) {
          const [a, b, c] = combo;
          if (board[a] && board[a] === board[b] && board[a] === board[c]) {
            return board[a];
          }
        }

        return '';
      }

      // Show settings modal
      function showSettings() {
        // Set current settings in the form
        document.querySelector(
          `input[name="gameMode"][value="${gameSettings.gameMode}"]`,
        ).checked = true;
        document.querySelector(
          `input[name="rules"][value="${gameSettings.rules}"]`,
        ).checked = true;
        document.querySelector(
          `input[name="difficulty"][value="${gameSettings.difficulty}"]`,
        ).checked = true;

        // Show/hide AI difficulty based on game mode
        aiDifficultyGroup.style.display =
          gameSettings.gameMode === 'ai' ? 'block' : 'none';

        settingsModal.classList.add('show');
      }

      // Hide settings modal
      function hideSettings() {
        settingsModal.classList.remove('show');
      }

      // Show How to Play modal
      function showHowToPlay() {
        document.getElementById('howToPlayModal').classList.add('show');
      }

      // Hide How to Play modal
      function hideHowToPlay() {
        document.getElementById('howToPlayModal').classList.remove('show');
      }

      // Update the saveGameSettings function
      function saveGameSettings() {
        // Store the previous game mode
        const previousGameMode = gameSettings.gameMode;

        // Get selected game mode
        gameSettings.gameMode = document.querySelector(
          'input[name="gameMode"]:checked',
        ).value;

        // Get selected rules
        gameSettings.rules = document.querySelector(
          'input[name="rules"]:checked',
        ).value;

        // Get selected difficulty (only if in AI mode)
        if (gameSettings.gameMode === 'ai') {
          gameSettings.difficulty = document.querySelector(
            'input[name="difficulty"]:checked',
          ).value;
        }

        // Update game settings
        gameSettings.xColor = document.getElementById('xColorPicker').value;
        gameSettings.oColor = document.getElementById('oColorPicker').value;
        updateColors();

        // Update player O display based on the game mode
        if (gameSettings.gameMode === 'ai') {
          playerODisplay.innerHTML =
            '<i class="fas fa-robot"></i> <i class="far fa-circle"></i>';
        } else {
          playerODisplay.innerHTML =
            '<i class="fas fa-user"></i> <i class="far fa-circle"></i>';
        }

        // Save the updated game state
        saveGameState();

        // Check if we switched from human to AI mode and it's AI's turn
        if (
          previousGameMode === 'human' &&
          gameSettings.gameMode === 'ai' &&
          currentPlayer === 'o' &&
          gameActive
        ) {
          // Trigger AI move after a short delay
          setTimeout(() => aiMakeMove(), 500);
        }

        hideSettings();
      }

      // Flip a coin to determine who goes first
      function flipCoin() {
        const coin = document.getElementById('coin');
        coin.classList.add('flipping');
        coinResult.textContent = 'Flipping...';

        setTimeout(() => {
          coin.classList.remove('flipping');
          const result = Math.random() < 0.5 ? 'x' : 'o';
          currentPlayer = result;

          // Add a final flip position based on result
          coin.style.transform =
            result === 'x' ? 'rotateY(0deg)' : 'rotateY(180deg)';

          // Update result text with proper icon
          if (result === 'x') {
            coinResult.innerHTML =
              'Player <span style="color: ' +
              gameSettings.xColor +
              '"><i class="fas fa-times fa-lg"></i></span> goes first!';
          } else {
            coinResult.innerHTML =
              'Player <span style="color: ' +
              gameSettings.oColor +
              '"><i class="far fa-circle fa-lg"></i></span> goes first!';
          }

          // Update player display
          playerXDisplay.classList.toggle('active', result === 'x');
          playerODisplay.classList.toggle('active', result === 'o');

          // Start the game automatically after 1 second
          setTimeout(startGame, 1000);
        }, 1500);
      }

      // Start the game after coin flip
      function startGame() {
        gameActive = true;
        coinFlipModal.style.display = 'none';
        updateActiveBoards();

        // If it's AI's turn and we're in AI mode, make AI move
        if (gameSettings.gameMode === 'ai' && currentPlayer === 'o') {
          setTimeout(() => aiMakeMove(), 300);
        }
      }

      // Update findAndHighlightLastMove to use the stored lastMove information
      function findAndHighlightLastMove() {
        // If we have a valid lastMove stored, use it
        if (
          lastMove.boardIndex >= 0 &&
          lastMove.cellIndex >= 0 &&
          lastMove.player
        ) {
          const cell = document.querySelector(
            `.cell[data-board="${lastMove.boardIndex}"][data-cell="${lastMove.cellIndex}"]`,
          );
          if (cell) {
            cell.classList.add('last-move');
            return;
          }
        }

        // Fallback to the old method if no lastMove is stored
        // This is less reliable but maintains compatibility
        const lastPlayer = currentPlayer === 'x' ? 'o' : 'x';

        // Look through all boards and find the most recent move
        for (let i = 0; i < 9; i++) {
          for (let j = 0; j < 9; j++) {
            if (boards[i][j] === lastPlayer) {
              const cell = document.querySelector(
                `.cell[data-board="${i}"][data-cell="${j}"]`,
              );
              if (cell) {
                cell.classList.add('last-move');
                // We only want to highlight one cell as the last move
                return;
              }
            }
          }
        }
      }

      // Add function to handle closing modals when clicking outside
      function setupModalOutsideClickListeners() {
        // Add click event listeners to each modal
        document
          .querySelectorAll(
            '.settings-modal, .how-to-play-modal, .color-picker-modal',
          )
          .forEach(modal => {
            modal.addEventListener('click', function (event) {
              // If the click is directly on the modal (background) and not on its children
              if (event.target === modal) {
                // Settings modal
                if (modal.id === 'settingsModal') {
                  hideSettings();
                }
                // How to play modal
                else if (modal.id === 'howToPlayModal') {
                  hideHowToPlay();
                }
                // Color picker modal
                else if (modal.id === 'colorPickerModal') {
                  colorPickerModal.classList.remove('show');
                }
              }
            });
          });

        // Special case for game over modal
        document
          .getElementById('gameOver')
          .addEventListener('click', function (event) {
            // Only close if clicking directly on the background
            if (event.target === this) {
              gameOver.classList.remove('show');
            }
          });
      }

      // Event listeners for buttons
      if (howToPlayBtn) howToPlayBtn.addEventListener('click', showHowToPlay);
      if (closeHowToPlayBtn)
        closeHowToPlayBtn.addEventListener('click', hideHowToPlay);
      newGameBtn.addEventListener('click', () => {
        clearSavedGameState();
        initGame();
      });
      playAgainBtn.addEventListener('click', () => {
        clearSavedGameState();
        initGame();
      });
      viewBoardBtn.addEventListener('click', () =>
        gameOver.classList.remove('show'),
      );
      settingsBtn.addEventListener('click', showSettings);
      cancelSettings.addEventListener('click', hideSettings);
      saveSettings.addEventListener('click', saveGameSettings);

      // Update colors when the user selects a new color
      document
        .getElementById('xColorPicker')
        .addEventListener('input', event => {
          const newColor = event.target.value;
          gameSettings.xColor = newColor;
          updateColors();
        });

      document
        .getElementById('oColorPicker')
        .addEventListener('input', event => {
          const newColor = event.target.value;
          gameSettings.oColor = newColor;
          updateColors();
        });

      // Game mode change listener
      humanVsHuman.addEventListener('change', function () {
        if (this.checked) {
          aiDifficultyGroup.style.display = 'none';
        }
      });

      humanVsAI.addEventListener('change', function () {
        if (this.checked) {
          aiDifficultyGroup.style.display = 'block';
        }
      });

      // Initialize the game (load from storage or start new)
      initializeGame();
    </script>
  </body>
</html>
