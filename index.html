<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tic Tac Squared</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <style>
      :root {
        --x-color: #ff4757;
        --o-color: #1e90ff;
        --bg-color: #2f3542;
        --board-bg: #57606f;
        --highlight: rgba(255, 255, 255, 0.1);
        --text-light: #f1f2f6;
        --modal-bg: rgba(47, 53, 66, 0.95);
      }

      body {
        margin: 0;
        padding: 0;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-light);
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
      }

      header {
        text-align: center;
        margin-top: 20px;
        margin-bottom: 5px;
        width: 100%;
        position: relative;
      }

      h1 {
        font-size: 2.9rem;
        margin-bottom: 10px;
        color: white;
      }

      .game-info {
        display: flex;
        justify-content: space-between;
        width: 500px;
        margin: 0 auto 20px;
        font-size: 1.2rem;
        font-weight: bold;
      }

      .player {
        padding: 10px 20px;
        border-radius: 5px;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .player.active {
        background-color: var(--highlight);
      }

      .player-x {
        color: var(--x-color);
      }

      .player-o {
        color: var(--o-color);
      }

      .super-board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        gap: 10px;
        width: 500px;
        height: 500px;
        margin: 0 auto;
        position: relative;
      }

      .board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        gap: 5px;
        background-color: var(--board-bg);
        border-radius: 8px;
        padding: 5px;
        position: relative;
        overflow: hidden;
      }

      .board.active {
        box-shadow: 0 0 0 3px var(--text-light);
        animation: pulse 1.5s infinite;
      }

      .board.won-x {
        background-color: rgba(255, 71, 87, 0.2);
        border: 3px solid var(--x-color);
      }

      .board.won-o {
        background-color: rgba(30, 144, 255, 0.2);
        border: 3px solid var(--o-color);
      }

      .board.tie {
        background-color: rgba(113, 128, 147, 0.5);
        border: 3px solid var(--text-light);
      }

      .cell {
        background-color: var(--bg-color);
        border-radius: 4px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 24px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
        position: relative;
        z-index: 2;
      }

      .cell:hover:not(.occupied) {
        background-color: var(--highlight);
      }

      .cell.x {
        color: var(--x-color);
      }

      .cell.o {
        color: var(--o-color);
      }

      .cell.last-move {
        position: relative;
      }

      .cell.last-move::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: currentColor;
        opacity: 0.15;
        pointer-events: none;
        border-radius: 4px;
      }

      .winning-line {
        position: absolute;
        background-color: rgba(255, 255, 255, 0.8);
        z-index: 5;
        transform-origin: 0 0;
      }

      .controls {
        margin-top: 30px;
        margin-bottom: 30px;
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        justify-content: center;
      }

      button {
        padding: 10px 20px;
        background-color: var(--board-bg);
        color: var(--text-light);
        border: none;
        border-radius: 5px;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      .ai-thinking {
        margin-top: 20px;
        font-style: italic;
        opacity: 0;
        transition: opacity 0.3s;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .ai-thinking.show {
        opacity: 1;
      }

      .game-over {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s;
      }

      .game-over.show {
        opacity: 1;
        pointer-events: all;
      }

      .game-over-message {
        font-size: 3rem;
        font-weight: bold;
        margin-bottom: 20px;
        text-align: center;
      }

      .game-over-message.x {
        color: var(--x-color);
      }

      .game-over-message.o {
        color: var(--o-color);
      }

      .game-over-message.tie {
        color: var(--text-light);
      }

      .game-over-buttons {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        justify-content: center;
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 3px var(--text-light);
        }
        50% {
          box-shadow: 0 0 0 6px var(--text-light);
        }
        100% {
          box-shadow: 0 0 0 3px var(--text-light);
        }
      }

      .settings-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--modal-bg);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 200;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s;
      }

      .settings-modal.show {
        opacity: 1;
        pointer-events: all;
      }

      .settings-content {
        background-color: var(--board-bg);
        padding: 30px;
        border-radius: 10px;
        width: 400px;
        max-width: 90%;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      }

      .settings-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .settings-title {
        font-size: 1.5rem;
        margin: 0;
      }

      .setting-group {
        margin-bottom: 20px;
      }

      .setting-label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
      }

      .setting-option {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }

      .setting-option input {
        margin-right: 10px;
      }

      .color-picker {
        display: flex;
        gap: 15px;
        margin-top: 15px;
      }

      .color-option {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 10px;
      }

      .color-box {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid transparent;
        transition: transform 0.2s;
      }

      .color-box.selected {
        border-color: var(--text-light);
        transform: scale(1.1);
      }

      .settings-footer {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 30px;
      }

      .coin-flip-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 300;
      }

      .coin-flip-content {
        background-color: var(--board-bg);
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        max-width: 90%;
      }

      .coin {
        width: 100px;
        height: 100px;
        margin: 20px auto;
        position: relative;
        transform-style: preserve-3d;
        transition: transform 0.1s;
      }

      .coin.flipping {
        animation: flip-coin 1.5s ease-out forwards;
      }

      .coin-side {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        backface-visibility: hidden;
        font-size: 2.5rem;
        font-weight: bold;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      }

      .coin-side.heads {
        background: linear-gradient(45deg, #ffd700, #ffcc00);
        border: 4px solid #e6b800;
        color: var(--x-color);
        z-index: 2;
      }

      .coin-side.tails {
        background: linear-gradient(45deg, #ffd700, #ffcc00);
        border: 4px solid #e6b800;
        color: var(--o-color);
        transform: rotateY(180deg);
      }

      input[type='color']::-moz-color-swatch {
        border: none;
      }

      input[type='color']::-webkit-color-swatch-wrapper {
        padding: 0;
        border-radius: 0;
      }

      input[type='color']::-webkit-color-swatch {
        border: none;
      }

      @keyframes flip-coin {
        0% {
          transform: rotateY(0) rotateX(0);
        }
        20% {
          transform: rotateY(180deg) rotateX(720deg);
        }
        40% {
          transform: rotateY(360deg) rotateX(1440deg);
        }
        60% {
          transform: rotateY(540deg) rotateX(2160deg);
        }
        80% {
          transform: rotateY(720deg) rotateX(2880deg);
        }
        100% {
          transform: rotateY(900deg) rotateX(3600deg);
        }
      }

      .color-picker-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 400;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s;
      }

      .color-picker-modal.show {
        opacity: 1;
        pointer-events: all;
      }

      .color-picker-content {
        background-color: var(--board-bg);
        padding: 20px;
        border-radius: 10px;
        text-align: center;
      }

      .color-picker-input {
        width: 100%;
        margin: 15px 0;
      }

      .color-picker-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 15px;
      }

      @media (max-width: 600px) {
        .super-board {
          width: 90vw;
          height: 90vw;
        }

        .game-info {
          width: 90vw;
          font-size: 1rem;
        }

        .controls {
          width: 90vw;
        }

        .game-over-message {
          font-size: 2rem;
        }

        .game-over-buttons {
          flex-direction: column;
          width: 80%;
        }

        .game-over-buttons button {
          width: 100%;
        }

        .player {
          padding: 8px 12px;
          font-size: 0.9rem;
        }

        h1 {
          font-size: 2rem;
        }
      }

      .how-to-play-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--modal-bg);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 200;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s;
      }

      .how-to-play-modal.show {
        opacity: 1;
        pointer-events: all;
      }

      .how-to-play-content {
        background-color: var(--board-bg);
        padding: 30px;
        border-radius: 10px;
        width: 600px;
        max-width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      }

      .how-to-play-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .how-to-play-title {
        font-size: 1.5rem;
        margin: 0;
      }

      .how-to-play-body {
        margin-bottom: 20px;
      }

      .how-to-play-body h3 {
        margin-top: 16px;
        margin-bottom: 8px;
        color: var(--text-light);
      }

      .how-to-play-body p,
      .how-to-play-body li {
        margin-bottom: 8px;
        line-height: 1.5;
      }

      .how-to-play-footer {
        display: flex;
        justify-content: center;
      }

      /* Add transparent border to modal buttons */
      .settings-modal button,
      .how-to-play-modal button,
      .color-picker-modal button,
      .game-over button {
        border: 1px solid rgba(255, 255, 255, 0.3);
        transition: all 0.3s;
      }

      .settings-modal button:hover,
      .how-to-play-modal button:hover,
      .color-picker-modal button:hover,
      .game-over button:hover {
        border-color: rgba(255, 255, 255, 0.8);
      }

      /* Add two-column layout for settings */
      .settings-columns {
        display: flex;
        gap: 20px;
      }

      .settings-column {
        flex: 1;
      }

      /* Make sure AI difficulty group doesn't increase modal height */
      #aiDifficultyGroup {
        display: none;
      }

      /* Add style for the reset color buttons */
      .reset-color-btn {
        background: none;
        border: none;
        color: var(--text-light);
        cursor: pointer;
        padding: 5px;
        border-radius: 50%;
        font-size: 0.9rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        margin-left: 5px;
      }

      .reset-color-btn:hover {
        background-color: var(--highlight);
        transform: rotate(-45deg);
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Tic Tac Squared</h1>
      <div class="game-info">
        <div class="player player-x active">
          <i class="fas fa-user"></i> <i class="fas fa-times fa-lg"></i>
        </div>
        <div id="aiThinking" class="ai-thinking">
          AI thinking... <i class="fas fa-cog fa-spin"></i>
        </div>
        <div class="player player-o">
          <i class="fas fa-robot"></i> <i class="far fa-circle"></i>
        </div>
      </div>
    </header>

    <div id="superBoard" class="super-board"></div>

    <div class="settings-modal" id="settingsModal">
      <div class="settings-content">
        <div class="settings-header">
          <h3 class="settings-title">Game Settings</h3>
        </div>

        <div class="settings-columns">
          <div class="settings-column">
            <div class="setting-group">
              <label class="setting-label">Game Mode:</label>
              <div class="setting-option">
                <input
                  type="radio"
                  id="humanVsHuman"
                  name="gameMode"
                  value="human" />
                <label for="humanVsHuman">Human vs Human</label>
              </div>
              <div class="setting-option">
                <input
                  type="radio"
                  id="humanVsAI"
                  name="gameMode"
                  value="ai"
                  checked />
                <label for="humanVsAI">Human vs AI</label>
              </div>
              <div class="setting-option">
                <input
                  type="radio"
                  id="aiVsAi"
                  name="gameMode"
                  value="aivsai" />
                <label for="aiVsAi">AI vs AI</label>
              </div>
            </div>
          </div>

          <div class="settings-column">
            <div class="setting-group" id="aiDifficultyGroup">
              <label class="setting-label">AI Difficulty:</label>
              <div class="setting-option">
                <input
                  type="radio"
                  id="easyAI"
                  name="difficulty"
                  value="easy" />
                <label for="easyAI">Easy</label>
              </div>
              <div class="setting-option">
                <input
                  type="radio"
                  id="mediumAI"
                  name="difficulty"
                  value="medium"
                  checked />
                <label for="mediumAI">Medium</label>
              </div>
              <div class="setting-option">
                <input
                  type="radio"
                  id="hardAI"
                  name="difficulty"
                  value="hard" />
                <label for="hardAI">Hard</label>
              </div>
            </div>
          </div>
        </div>

        <div class="setting-group">
          <label class="setting-label">Rules:</label>
          <div class="setting-option">
            <input
              type="radio"
              id="standardRules"
              name="rules"
              value="standard"
              checked />
            <label for="standardRules"
              >Standard (next board determined by last move)</label
            >
          </div>
          <div class="setting-option">
            <input type="radio" id="freeRules" name="rules" value="free" />
            <label for="freeRules"
              >Free Play (move in any board at any time)</label
            >
          </div>
        </div>

        <div class="setting-group">
          <label class="setting-label">Player Colors:</label>
          <div class="color-picker">
            <div class="color-option">
              <label>X Color</label>
              <input
                type="color"
                id="xColorPicker"
                class="color-box"
                data-player="x"
                value="#ff4757"
                style="
                  background-color: transparent;
                  border: 0;
                  width: 30px;
                  height: 30px;
                  border-radius: 50%;
                  cursor: pointer;
                  appearance: none;
                  -webkit-appearance: none;
                  padding: 0;
                  overflow: hidden;
                " />
              <button class="reset-color-btn" id="resetXColor">
                <i class="fas fa-undo-alt"></i>
              </button>
            </div>
            <div class="color-option">
              <label>O Color</label>
              <input
                type="color"
                id="oColorPicker"
                class="color-box"
                data-player="o"
                value="#1e90ff"
                style="
                  background-color: transparent;
                  border: 0;
                  width: 30px;
                  height: 30px;
                  border-radius: 50%;
                  cursor: pointer;
                  appearance: none;
                  -webkit-appearance: none;
                  padding: 0;
                  overflow: hidden;
                " />
              <button class="reset-color-btn" id="resetOColor">
                <i class="fas fa-undo-alt"></i>
              </button>
            </div>
          </div>
        </div>

        <div class="settings-footer">
          <button id="saveSettings"><i class="fas fa-save"></i> Save</button>
          <button id="cancelSettings"><i class="fas fa-times"></i> Exit</button>
        </div>
      </div>
    </div>

    <div class="coin-flip-modal" id="coinFlipModal">
      <div class="coin-flip-content">
        <h2>Flip a Coin</h2>
        <p>Determining who goes first...</p>
        <div class="coin" id="coin">
          <div class="coin-side heads">
            <i class="fas fa-times fa-2x"></i>
          </div>
          <div class="coin-side tails">
            <i class="far fa-circle fa-2x"></i>
          </div>
        </div>
        <div id="coinResult"></div>
      </div>
    </div>

    <div class="how-to-play-modal" id="howToPlayModal">
      <div class="how-to-play-content">
        <div class="how-to-play-header">
          <h3 class="how-to-play-title">How to Play</h3>
        </div>

        <div class="how-to-play-body">
          <h3>Basic Rules</h3>
          <ul>
            <li>Players take turns marking spaces with X or O.</li>
            <li>
              Win a small board by getting three of your marks in a row
              (horizontally, vertically, or diagonally).
            </li>
            <li>
              Win the game by winning three small boards in a row on the super
              board.
            </li>
          </ul>

          <h3>Board Selection Rules</h3>
          <p>
            <strong>Standard Rules:</strong> Your move sends your opponent to
            the corresponding board. For example, if you play in the top-right
            cell of any board, your opponent must play in the top-right board.
          </p>
          <p>
            <strong>Free Play:</strong> Players can play in any non-completed
            board on their turn.
          </p>

          <h3>Special Situations</h3>
          <ul>
            <li>
              If you're sent to a board that's already won or tied, you can play
              in any available board.
            </li>
            <li>
              A tied board (filled with no winner) doesn't count for either
              player.
            </li>
          </ul>
        </div>

        <div class="how-to-play-footer">
          <button id="closeHowToPlayBtn">
            <i class="fas fa-check"></i> Got It
          </button>
        </div>
      </div>
    </div>

    <div class="color-picker-modal" id="colorPickerModal">
      <div class="color-picker-content">
        <h3 id="colorPickerTitle">Select Color</h3>
        <input type="color" id="colorPickerInput" class="color-picker-input" />
        <div class="color-picker-buttons">
          <button id="confirmColorBtn">
            <i class="fas fa-check"></i> Confirm
          </button>
          <button id="cancelColorBtn">
            <i class="fas fa-times"></i> Cancel
          </button>
        </div>
      </div>
    </div>

    <div class="controls">
      <button id="howToPlayBtn">
        <i class="fas fa-question-circle"></i> How to Play
      </button>
      <button id="settingsBtn"><i class="fas fa-cog"></i> Settings</button>
      <button id="newGameBtn">
        <i class="fas fa-plus-circle"></i> New Game
      </button>
    </div>

    <div class="game-over" id="gameOver">
      <div id="gameOverMessage" class="game-over-message"></div>
      <div class="game-over-buttons">
        <button id="playAgainBtn">
          <i class="fas fa-sync-alt"></i> Play Again
        </button>
        <button id="viewBoardBtn"><i class="fas fa-eye"></i> View Board</button>
      </div>
    </div>

    <script>
      // Game elements
      const superBoard = document.getElementById('superBoard');
      const playerXDisplay = document.querySelector('.player-x');
      const playerODisplay = document.querySelector('.player-o');
      const aiThinking = document.getElementById('aiThinking');
      const howToPlayBtn = document.getElementById('howToPlayBtn');
      const newGameBtn = document.getElementById('newGameBtn');
      const gameOver = document.getElementById('gameOver');
      const gameOverMessage = document.getElementById('gameOverMessage');
      const playAgainBtn = document.getElementById('playAgainBtn');
      const viewBoardBtn = document.getElementById('viewBoardBtn');
      const settingsBtn = document.getElementById('settingsBtn');
      const settingsModal = document.getElementById('settingsModal');
      const saveSettings = document.getElementById('saveSettings');
      const cancelSettings = document.getElementById('cancelSettings');
      const humanVsHumanRadio = document.getElementById('humanVsHuman');
      const humanVsAIRadio = document.getElementById('humanVsAI');
      // const aiVsAiRadio = document.getElementById('aiVsAi'); // Reference removed - AIvAI functionality disabled
      const aiDifficultyGroup = document.getElementById('aiDifficultyGroup');
      const coinFlipModal = document.getElementById('coinFlipModal');
      const coin = document.getElementById('coin');
      const coinResult = document.getElementById('coinResult');
      const xColorPicker = document.getElementById('xColorPicker');
      const oColorPicker = document.getElementById('oColorPicker');
      const resetXColorBtn = document.getElementById('resetXColor');
      const resetOColorBtn = document.getElementById('resetOColor');
      const howToPlayModal = document.getElementById('howToPlayModal');

      // Default color constants
      const DEFAULT_X_COLOR = '#ff4757';
      const DEFAULT_O_COLOR = '#1e90ff';

      // Add a timeout tracker for AI moves
      let pendingAIMove = null;

      // Game state
      let currentPlayer = ''; // x or o (empty before coin flip)
      let activeBoard = null; // which board is active (null means any board)
      let boards = Array(9)
        .fill()
        .map(() => Array(9).fill(''));
      let boardWinners = Array(9).fill(''); // 'x', 'o', 'tie', or ''
      let gameWinner = '';
      let gameActive = false; // starts false until coin flip
      let winningCombination = null;
      let lastMove = { boardIndex: -1, cellIndex: -1, player: '' };

      // Game settings (initialized with defaults)
      let gameSettings = {
        gameMode: 'ai', // 'human', 'ai' (aivsai removed)
        rules: 'standard', // 'standard' or 'free'
        xColor: DEFAULT_X_COLOR,
        oColor: DEFAULT_O_COLOR,
        difficulty: 'medium', // 'easy', 'medium', 'hard'
      };

      // Helper function to convert hex to rgba
      function hexToRGBA(hex, alpha) {
        if (!hex || hex.length < 7) {
          console.warn(`Invalid hex color: ${hex}. Using default.`);
          hex = '#000000'; // Default to black if invalid
        }
        try {
          let r = parseInt(hex.slice(1, 3), 16);
          let g = parseInt(hex.slice(3, 5), 16);
          let b = parseInt(hex.slice(5, 7), 16);
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        } catch (error) {
          console.error(`Error parsing hex color ${hex}:`, error);
          return `rgba(0, 0, 0, ${alpha})`; // Default to black RGBA
        }
      }

      // Update colors based on game settings
      function updateColors() {
        // Update CSS variables
        document.documentElement.style.setProperty(
          '--x-color',
          gameSettings.xColor,
        );
        document.documentElement.style.setProperty(
          '--o-color',
          gameSettings.oColor,
        );

        // Update player displays
        // Player X is always user unless gameMode changes (handled in settings save)
        // Player O is user in human mode, robot in AI mode
        const playerXIcon = 'fa-user'; // X is always human now
        const playerOIcon =
          gameSettings.gameMode === 'human' ? 'fa-user' : 'fa-robot';
        playerXDisplay.innerHTML = `<i class="fas ${playerXIcon}"></i> <i class="fas fa-times fa-lg"></i>`;
        playerODisplay.innerHTML = `<i class="fas ${playerOIcon}"></i> <i class="far fa-circle"></i>`;

        playerXDisplay.style.color = gameSettings.xColor;
        playerODisplay.style.color = gameSettings.oColor;

        // Update color pickers
        if (xColorPicker) {
          xColorPicker.value = gameSettings.xColor;
          xColorPicker.style.backgroundColor = gameSettings.xColor;
        }
        if (oColorPicker) {
          oColorPicker.value = gameSettings.oColor;
          oColorPicker.style.backgroundColor = gameSettings.oColor;
        }

        // Update existing board visuals
        document.querySelectorAll('.board.won-x').forEach(board => {
          board.style.borderColor = gameSettings.xColor;
          board.style.backgroundColor = hexToRGBA(gameSettings.xColor, 0.2);
        });
        document.querySelectorAll('.board.won-o').forEach(board => {
          board.style.borderColor = gameSettings.oColor;
          board.style.backgroundColor = hexToRGBA(gameSettings.oColor, 0.2);
        });

        // Update existing cell colors
        document.querySelectorAll('.cell.x').forEach(cell => {
          cell.style.color = gameSettings.xColor;
        });
        document.querySelectorAll('.cell.o').forEach(cell => {
          cell.style.color = gameSettings.oColor;
        });

        // Update winning lines colors
        document.querySelectorAll('.winning-line').forEach(line => {
          const boardElement = line.closest('.board');
          if (boardElement) {
            const boardIndex = parseInt(boardElement.dataset.index);
            if (boardWinners[boardIndex] === 'x')
              line.style.backgroundColor = gameSettings.xColor;
            else if (boardWinners[boardIndex] === 'o')
              line.style.backgroundColor = gameSettings.oColor;
            else line.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
          } else if (superBoard.contains(line)) {
            if (gameWinner === 'x')
              line.style.backgroundColor = gameSettings.xColor;
            else if (gameWinner === 'o')
              line.style.backgroundColor = gameSettings.oColor;
            else line.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
          }
        });

        // Update coin colors
        const coinHeads = document.querySelector('.coin-side.heads');
        const coinTails = document.querySelector('.coin-side.tails');
        if (coinHeads) coinHeads.style.color = gameSettings.xColor;
        if (coinTails) coinTails.style.color = gameSettings.oColor;
      }

      // Save game state to localStorage
      function saveGameState() {
        const gameState = {
          currentPlayer,
          activeBoard,
          boards,
          boardWinners,
          gameWinner,
          gameActive,
          winningCombination,
          lastMove,
        };
        localStorage.setItem('ticTacSquaredState', JSON.stringify(gameState));
        localStorage.setItem(
          'ticTacSquaredPreferences',
          JSON.stringify(gameSettings),
        );
      }

      // Load preferences function
      function loadPreferences() {
        const savedPrefs = localStorage.getItem('ticTacSquaredPreferences');
        if (savedPrefs) {
          try {
            const prefs = JSON.parse(savedPrefs);
            const validPrefs = {};
            // Only allow 'human' or 'ai' for gameMode now
            if (['human', 'ai'].includes(prefs.gameMode))
              validPrefs.gameMode = prefs.gameMode;
            if (['standard', 'free'].includes(prefs.rules))
              validPrefs.rules = prefs.rules;
            if (prefs.xColor) validPrefs.xColor = prefs.xColor;
            if (prefs.oColor) validPrefs.oColor = prefs.oColor;
            if (['easy', 'medium', 'hard'].includes(prefs.difficulty))
              validPrefs.difficulty = prefs.difficulty;
            gameSettings = { ...gameSettings, ...validPrefs };
          } catch (e) {
            console.error('Error loading preferences:', e);
            localStorage.removeItem('ticTacSquaredPreferences');
          }
        }
        // Ensure gameMode is valid after loading, default to 'ai' if invalid
        if (!['human', 'ai'].includes(gameSettings.gameMode)) {
          gameSettings.gameMode = 'ai';
        }
        // If no previous state exists, reset to default settings
        if (!localStorage.getItem('ticTacSquaredState')) {
          gameSettings.gameMode = 'ai';
          gameSettings.rules = 'standard';
          gameSettings.difficulty = 'medium';
        }
        updateColors();
      }

      // Update the loadGameState function to trigger AI move if needed
      function loadGameState() {
        if (pendingAIMove !== null) {
          clearTimeout(pendingAIMove);
          pendingAIMove = null;
        }
        try {
          const savedState = localStorage.getItem('ticTacSquaredState');
          if (!savedState) return false;
          const gameState = JSON.parse(savedState);
          updateColors(); // Apply loaded preferences first

          currentPlayer = gameState.currentPlayer;
          activeBoard = gameState.activeBoard;
          boards = gameState.boards;
          boardWinners = gameState.boardWinners;
          gameWinner = gameState.gameWinner;
          gameActive = gameState.gameActive;
          winningCombination = gameState.winningCombination;
          lastMove = gameState.lastMove || {
            boardIndex: -1,
            cellIndex: -1,
            player: '',
          };

          superBoard.innerHTML = '';
          recreateGameUI();
          coinFlipModal.style.display = 'none';

          // Trigger AI move if loaded state requires it (Human vs AI only)
          if (
            gameActive &&
            !gameWinner &&
            gameSettings.gameMode === 'ai' &&
            currentPlayer === 'o'
          ) {
            aiThinking.classList.add('show');
            pendingAIMove = setTimeout(() => {
              pendingAIMove = null;
              if (!gameActive || gameWinner) {
                aiThinking.classList.remove('show');
                return;
              }
              aiMakeMove();
            }, 800);
          }

          console.log('Loaded saved game state');
          return true;
        } catch (error) {
          console.error('Error loading saved game:', error);
          localStorage.removeItem('ticTacSquaredState');
          return false;
        }
      }

      // Clear saved game state
      function clearSavedGameState() {
        localStorage.removeItem('ticTacSquaredState');
        console.log('Cleared saved game state.');
      }

      // Recreate the board UI from the current game state
      function recreateGameUI() {
        for (let i = 0; i < 9; i++) {
          const board = document.createElement('div');
          board.className = 'board';
          board.dataset.index = i;
          for (let j = 0; j < 9; j++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.board = i;
            cell.dataset.cell = j;
            cell.addEventListener('click', handleCellClick);
            if (boards[i][j] === 'x') {
              cell.classList.add('x', 'occupied');
              cell.innerHTML = '<i class="fas fa-times fa-lg"></i>';
              cell.style.color = gameSettings.xColor;
            } else if (boards[i][j] === 'o') {
              cell.classList.add('o', 'occupied');
              cell.innerHTML = '<i class="far fa-circle"></i>';
              cell.style.color = gameSettings.oColor;
            }
            board.appendChild(cell);
          }
          let boardOpacity = '1';
          if (boardWinners[i] === 'x') {
            board.classList.add('won-x');
            board.style.borderColor = gameSettings.xColor;
            board.style.backgroundColor = hexToRGBA(gameSettings.xColor, 0.2);
            boardOpacity = '0.6';
          } else if (boardWinners[i] === 'o') {
            board.classList.add('won-o');
            board.style.borderColor = gameSettings.oColor;
            board.style.backgroundColor = hexToRGBA(gameSettings.oColor, 0.2);
            boardOpacity = '0.6';
          } else if (boardWinners[i] === 'tie') {
            board.classList.add('tie');
            boardOpacity = '0.6';
          }
          if (boardOpacity !== '1') {
            board.querySelectorAll('.cell').forEach(cell => {
              cell.style.opacity = boardOpacity;
            });
          }
          superBoard.appendChild(board);
        }

        playerXDisplay.classList.toggle('active', currentPlayer === 'x');
        playerODisplay.classList.toggle('active', currentPlayer === 'o');
        updateActiveBoards();

        if (gameWinner) {
          displayEndGameMessage();
          if (winningCombination && gameWinner !== 'tie') {
            setTimeout(() => drawSuperWinningLine(winningCombination), 100);
          }
          gameOver.classList.add('show');
        } else if (!gameActive && currentPlayer) {
          playerXDisplay.classList.toggle('active', currentPlayer === 'x');
          playerODisplay.classList.toggle('active', currentPlayer === 'o');
          updateActiveBoards();
        }

        for (let i = 0; i < 9; i++) {
          if (boardWinners[i] === 'x' || boardWinners[i] === 'o') {
            const winningCombo = findWinningCombo(i);
            if (winningCombo) {
              setTimeout(() => drawWinningLine(i, winningCombo), 100);
            }
          }
        }
        findAndHighlightLastMove();
      }

      // Find winning combo for a board
      function findWinningCombo(boardIndex) {
        if (
          boardWinners[boardIndex] !== 'x' &&
          boardWinners[boardIndex] !== 'o'
        )
          return null;
        const board = boards[boardIndex];
        const winningCombos = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8],
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8],
          [0, 4, 8],
          [2, 4, 6],
        ];
        for (const combo of winningCombos) {
          const [a, b, c] = combo;
          if (
            board[a] === boardWinners[boardIndex] &&
            board[b] === boardWinners[boardIndex] &&
            board[c] === boardWinners[boardIndex]
          ) {
            return combo;
          }
        }
        console.warn(
          `Could not find winning combo for board ${boardIndex} marked as won by ${boardWinners[boardIndex]}`,
        );
        return null;
      }

      // --- Coin Flip Logic ---
      function flipCoin() {
        coin.classList.remove('flipping');
        coinResult.textContent = '';
        void coin.offsetWidth; // Force reflow to restart animation

        // Determine who will go first
        const randomResult = Math.random();
        const winner = randomResult < 0.5 ? 'x' : 'o';

        // Start flipping animation
        coin.classList.add('flipping');

        setTimeout(() => {
          // After animation, remove the class to stop it
          coin.classList.remove('flipping');

          // Set the final rotation explicitly based on winner
          if (winner === 'x') {
            // Show X side up (heads)
            coin.style.transform = 'rotateY(0deg) rotateX(0deg)';
          } else {
            // Show O side up (tails)
            coin.style.transform = 'rotateY(180deg) rotateX(0deg)';
          }

          // Update result text with matching color
          coinResult.innerHTML = `<span style="color: ${
            winner === 'x' ? gameSettings.xColor : gameSettings.oColor
          }; font-weight: bold;">${winner.toUpperCase()} goes first!</span>`;

          // Start the game with the correct player
          setTimeout(() => {
            coinFlipModal.style.display = 'none';
            startGame(winner);
          }, 1500);
        }, 1500);
      }

      // --- Game Start Logic (after coin flip) ---
      function startGame(startingPlayer) {
        currentPlayer = startingPlayer;
        gameActive = true;
        activeBoard = null;
        playerXDisplay.classList.toggle('active', currentPlayer === 'x');
        playerODisplay.classList.toggle('active', currentPlayer === 'o');
        updateActiveBoards();
        saveGameState();
        // Trigger AI move only if AI (O) starts in Human vs AI mode
        if (gameSettings.gameMode === 'ai' && currentPlayer === 'o') {
          aiThinking.classList.add('show');
          pendingAIMove = setTimeout(() => {
            pendingAIMove = null;
            if (!gameActive) return;
            aiMakeMove();
          }, 800);
        }
      }

      // Update initGame to clear saved state and start the coin flip process
      function initGame() {
        if (pendingAIMove !== null) {
          clearTimeout(pendingAIMove);
          pendingAIMove = null;
        }
        clearSavedGameState();

        // Set explicit defaults for a fresh game
        gameSettings.gameMode = 'ai'; // Human vs AI
        gameSettings.rules = 'standard';
        gameSettings.difficulty = 'medium';

        // Save these default preferences
        localStorage.setItem(
          'ticTacSquaredPreferences',
          JSON.stringify(gameSettings),
        );

        superBoard.innerHTML = '';
        document.querySelectorAll('.winning-line').forEach(el => el.remove());
        currentPlayer = '';
        activeBoard = null;
        boards = Array(9)
          .fill()
          .map(() => Array(9).fill(''));
        boardWinners = Array(9).fill('');
        gameWinner = '';
        gameActive = false;
        winningCombination = null;
        lastMove = { boardIndex: -1, cellIndex: -1, player: '' };
        playerXDisplay.classList.remove('active');
        playerODisplay.classList.remove('active');
        updateColors();
        gameOver.classList.remove('show');
        aiThinking.classList.remove('show');
        for (let i = 0; i < 9; i++) {
          const board = document.createElement('div');
          board.className = 'board';
          board.dataset.index = i;
          for (let j = 0; j < 9; j++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.board = i;
            cell.dataset.cell = j;
            cell.addEventListener('click', handleCellClick);
            board.appendChild(cell);
          }
          superBoard.appendChild(board);
        }
        coinFlipModal.style.display = 'flex';
        flipCoin();
      }

      // Handle cell click event
      function handleCellClick(event) {
        if (!gameActive || gameWinner) return;
        const cellElement = event.currentTarget;
        const boardIndex = parseInt(cellElement.dataset.board);
        const cellIndex = parseInt(cellElement.dataset.cell);
        // Determine if it's a human player's turn
        const isHumanTurn =
          gameSettings.gameMode === 'human' ||
          (gameSettings.gameMode === 'ai' && currentPlayer === 'x');
        if (!isHumanTurn) {
          console.log('Not human turn, click ignored.');
          return;
        }
        if (boards[boardIndex][cellIndex] !== '') return;
        const boardElement = cellElement.closest('.board');
        if (!boardElement.classList.contains('active')) return;

        makeMove(boardIndex, cellIndex, currentPlayer);

        // Trigger AI move if applicable (Human vs AI mode, and now it's O's turn)
        if (
          gameActive &&
          !gameWinner &&
          gameSettings.gameMode === 'ai' &&
          currentPlayer === 'o'
        ) {
          aiThinking.classList.add('show');
          if (pendingAIMove !== null) {
            clearTimeout(pendingAIMove);
            pendingAIMove = null;
          }
          pendingAIMove = setTimeout(() => {
            pendingAIMove = null;
            if (!gameActive || gameWinner) {
              aiThinking.classList.remove('show');
              return;
            }
            aiMakeMove();
          }, 800);
        }
      }

      // Make a move (called by human click or AI)
      function makeMove(boardIndex, cellIndex, player) {
        if (!gameActive || gameWinner || boards[boardIndex][cellIndex] !== '') {
          console.warn(
            `Invalid move attempt: b${boardIndex}, c${cellIndex} by ${player}`,
          );
          return;
        }
        boards[boardIndex][cellIndex] = player;
        const lastCell = document.querySelector('.cell.last-move');
        if (lastCell) lastCell.classList.remove('last-move');
        const cell = document.querySelector(
          `.cell[data-board="${boardIndex}"][data-cell="${cellIndex}"]`,
        );
        cell.classList.add(player, 'occupied', 'last-move');
        cell.innerHTML =
          player === 'x'
            ? '<i class="fas fa-times fa-lg"></i>'
            : '<i class="far fa-circle"></i>';
        cell.style.color =
          player === 'x' ? gameSettings.xColor : gameSettings.oColor;
        lastMove = { boardIndex, cellIndex, player };
        if (boardWinners[boardIndex] === '') {
          checkBoardWinner(boardIndex);
        }

        const nextPlayer = player === 'x' ? 'o' : 'x';
        let nextActiveBoard = null;
        if (gameSettings.rules === 'standard') {
          nextActiveBoard = boardWinners[cellIndex] === '' ? cellIndex : null;
        } else {
          nextActiveBoard = null;
        }

        checkGameWinner(); // Check winner *before* switching player perspective

        if (gameActive && !gameWinner) {
          currentPlayer = nextPlayer;
          activeBoard = nextActiveBoard;
          playerXDisplay.classList.toggle('active', currentPlayer === 'x');
          playerODisplay.classList.toggle('active', currentPlayer === 'o');
          updateActiveBoards();
        } else if (gameWinner) {
          playerXDisplay.classList.remove('active');
          playerODisplay.classList.remove('active');
          updateActiveBoards();
        }
        saveGameState();
      }

      // Find and highlight the last move made
      function findAndHighlightLastMove() {
        document.querySelectorAll('.cell.last-move').forEach(cell => {
          cell.classList.remove('last-move');
        });
        if (
          lastMove &&
          lastMove.boardIndex !== -1 &&
          lastMove.cellIndex !== -1
        ) {
          const lastCellElement = document.querySelector(
            `.cell[data-board="${lastMove.boardIndex}"][data-cell="${lastMove.cellIndex}"]`,
          );
          if (lastCellElement) {
            lastCellElement.classList.add('last-move');
          }
        }
      }

      // Function to display the end game message
      function displayEndGameMessage() {
        if (gameWinner === 'x') {
          // Removed AIvAI check
          if (gameSettings.gameMode === 'ai')
            gameOverMessage.textContent = 'You Win!';
          else gameOverMessage.textContent = 'Player X Wins!';
          gameOverMessage.className = 'game-over-message x';
        } else if (gameWinner === 'o') {
          // Removed AIvAI check
          if (gameSettings.gameMode === 'ai')
            gameOverMessage.textContent = 'AI Wins!';
          else gameOverMessage.textContent = 'Player O Wins!';
          gameOverMessage.className = 'game-over-message o';
        } else {
          gameOverMessage.textContent = 'Game Tied!';
          gameOverMessage.className = 'game-over-message tie';
        }
      }

      // Update endGame to use the display function and save state
      function endGame() {
        if (!gameActive) return;
        gameActive = false;
        aiThinking.classList.remove('show');
        if (pendingAIMove) {
          clearTimeout(pendingAIMove);
          pendingAIMove = null;
        }
        playerXDisplay.classList.remove('active');
        playerODisplay.classList.remove('active');
        document
          .querySelectorAll('.board.active')
          .forEach(b => b.classList.remove('active'));
        displayEndGameMessage();
        if (winningCombination && gameWinner !== 'tie') {
          setTimeout(() => drawSuperWinningLine(winningCombination), 100);
        }
        saveGameState();
        gameOver.classList.add('show');
      }

      // Check if a board has a winner
      function checkBoardWinner(boardIndex) {
        if (boardWinners[boardIndex] !== '') return;
        const boardState = boards[boardIndex];
        const winningCombos = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8],
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8],
          [0, 4, 8],
          [2, 4, 6],
        ];
        for (const combo of winningCombos) {
          const [a, b, c] = combo;
          if (
            boardState[a] &&
            boardState[a] === boardState[b] &&
            boardState[a] === boardState[c]
          ) {
            boardWinners[boardIndex] = boardState[a];
            updateBoardUI(boardIndex, combo);
            return;
          }
        }
        if (!boardState.includes('')) {
          boardWinners[boardIndex] = 'tie';
          updateBoardUI(boardIndex);
        }
      }

      // Check if a temporary board state has a winner ('x', 'o', 'tie', or '')
      function checkTempBoardWinner(boardState) {
        const winningCombos = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8],
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8],
          [0, 4, 8],
          [2, 4, 6],
        ];
        for (const combo of winningCombos) {
          const [a, b, c] = combo;
          if (
            boardState[a] &&
            boardState[a] === boardState[b] &&
            boardState[a] === boardState[c]
          ) {
            return boardState[a];
          }
        }
        if (!boardState.includes('')) {
          return 'tie';
        }
        return '';
      }

      // Update board UI when it's won or tied
      function updateBoardUI(boardIndex, winningCombo = null) {
        const boardElement = document.querySelector(
          `.board[data-index="${boardIndex}"]`,
        );
        if (!boardElement) return;
        let boardOpacity = '1';
        boardElement.classList.remove('won-x', 'won-o', 'tie');
        boardElement.style.backgroundColor = '';
        boardElement.style.borderColor = '';
        if (boardWinners[boardIndex] === 'x') {
          boardElement.classList.add('won-x');
          boardElement.style.borderColor = gameSettings.xColor;
          boardElement.style.backgroundColor = hexToRGBA(
            gameSettings.xColor,
            0.2,
          );
          boardOpacity = '0.6';
        } else if (boardWinners[boardIndex] === 'o') {
          boardElement.classList.add('won-o');
          boardElement.style.borderColor = gameSettings.oColor;
          boardElement.style.backgroundColor = hexToRGBA(
            gameSettings.oColor,
            0.2,
          );
          boardOpacity = '0.6';
        } else if (boardWinners[boardIndex] === 'tie') {
          boardElement.classList.add('tie');
          boardOpacity = '0.6';
        }
        boardElement.querySelectorAll('.cell').forEach(cell => {
          cell.style.opacity = boardOpacity;
          if (boardOpacity !== '1') {
            cell.style.cursor = 'default';
          }
        });
        if (winningCombo) {
          const existingLine = boardElement.querySelector('.winning-line');
          if (existingLine) existingLine.remove();
          setTimeout(() => drawWinningLine(boardIndex, winningCombo), 50);
        }
      }

      // Draw winning line on a board
      function drawWinningLine(boardIndex, combo) {
        const boardElement = document.querySelector(
          `.board[data-index="${boardIndex}"]`,
        );
        if (!boardElement || !combo) return;
        const existingLine = boardElement.querySelector('.winning-line');
        if (existingLine) return;
        const boardWidth = boardElement.offsetWidth;
        const boardHeight = boardElement.offsetHeight;
        const gap = 5;
        const padding = 5;
        const cellWidth = (boardWidth - 2 * padding - 2 * gap) / 3;
        const cellHeight = (boardHeight - 2 * padding - 2 * gap) / 3;
        const lineThickness = 4;
        const [a, c] = [combo[0], combo[2]];
        const aCol = a % 3;
        const aRow = Math.floor(a / 3);
        const cCol = c % 3;
        const cRow = Math.floor(c / 3);
        const startXCenter = padding + aCol * (cellWidth + gap) + cellWidth / 2;
        const startYCenter =
          padding + aRow * (cellHeight + gap) + cellHeight / 2;
        const endXCenter = padding + cCol * (cellWidth + gap) + cellWidth / 2;
        const endYCenter = padding + cRow * (cellHeight + gap) + cellHeight / 2;
        const deltaX = endXCenter - startXCenter;
        const deltaY = endYCenter - startYCenter;
        const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const angleRad = Math.atan2(deltaY, deltaX);
        const line = document.createElement('div');
        line.className = 'winning-line';
        line.style.width = `${length}px`;
        line.style.height = `${lineThickness}px`;
        line.style.left = `${startXCenter}px`;
        line.style.top = `${startYCenter - lineThickness / 2}px`;
        line.style.transform = `rotate(${angleRad}rad)`;
        line.style.transformOrigin = `0 ${lineThickness / 2}px`;
        line.style.backgroundColor =
          boardWinners[boardIndex] === 'x'
            ? gameSettings.xColor
            : gameSettings.oColor;
        boardElement.appendChild(line);
      }

      // Draw winning line on the super board
      function drawSuperWinningLine(combo) {
        const existingLine = superBoard.querySelector(
          '.winning-line:not([data-board-index])',
        );
        if (existingLine) return;

        const [a, c] = [combo[0], combo[2]];
        const boardA = document.querySelector(`.board[data-index="${a}"]`);
        const boardC = document.querySelector(`.board[data-index="${c}"]`);

        if (!boardA || !boardC) {
          console.error('Could not find boards for super winning line', combo);
          return;
        }

        const boardARect = boardA.getBoundingClientRect();
        const boardCRect = boardC.getBoundingClientRect();
        const superBoardRect = superBoard.getBoundingClientRect();

        const aCol = a % 3;
        const aRow = Math.floor(a / 3);
        const cCol = c % 3;
        const cRow = Math.floor(c / 3);

        let startX, startY, endX, endY;
        const boardSize = superBoardRect.width / 3;
        const lineThickness = 10; // Thicker line for super board

        // For rows (horizontal lines)
        if (aRow === cRow) {
          startX = boardSize * 0.1 - 8.5;
          startY = aRow * boardSize + boardSize / 2;
          endX = superBoardRect.width - boardSize * 0.1 + 8.5;
          endY = startY;
        }
        // For columns (vertical lines)
        else if (aCol === cCol) {
          startX = aCol * boardSize + boardSize / 2;
          startY = boardSize * 0.1 - 8;
          endX = startX;
          endY = superBoardRect.height - boardSize * 0.1 + 7.5;
        }
        // For diagonals
        else {
          if (a === 0 && c === 8) {
            // Top-left to bottom-right diagonal
            startX = boardSize * 0.1;
            startY = boardSize * 0.1;
            endX = superBoardRect.width - boardSize * 0.1;
            endY = superBoardRect.height - boardSize * 0.1;
          } else {
            // Top-right to bottom-left diagonal
            startX = superBoardRect.width - boardSize * 0.1;
            startY = boardSize * 0.1;
            endX = boardSize * 0.1;
            endY = superBoardRect.height - boardSize * 0.1;
          }
        }

        const line = document.createElement('div');
        line.className = 'winning-line';

        // Calculate length and angle
        const deltaX = endX - startX;
        const deltaY = endY - startY;
        const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const angleRad = Math.atan2(deltaY, deltaX);

        // Set line properties
        line.style.width = `${length}px`;
        line.style.height = `${lineThickness}px`;
        line.style.left = `${startX}px`;
        line.style.top = `${startY - lineThickness / 2}px`;
        line.style.transform = `rotate(${angleRad}rad)`;
        line.style.transformOrigin = '0 50%';
        line.style.backgroundColor =
          gameWinner === 'x' ? gameSettings.xColor : gameSettings.oColor;
        line.style.zIndex = '10'; // Higher z-index to appear above board lines

        superBoard.appendChild(line);
      }

      // Check if the game has a winner
      function checkGameWinner() {
        if (gameWinner) return;
        const winningCombos = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8],
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8],
          [0, 4, 8],
          [2, 4, 6],
        ];
        for (const combo of winningCombos) {
          const [a, b, c] = combo;
          if (
            boardWinners[a] &&
            boardWinners[a] !== 'tie' &&
            boardWinners[a] === boardWinners[b] &&
            boardWinners[a] === boardWinners[c]
          ) {
            gameWinner = boardWinners[a];
            winningCombination = combo;
            endGame();
            return;
          }
        }
        if (boardWinners.every(winner => winner !== '')) {
          let foundWinner = false;
          for (const combo of winningCombos) {
            const [a, b, c] = combo;
            if (
              boardWinners[a] &&
              boardWinners[a] !== 'tie' &&
              boardWinners[a] === boardWinners[b] &&
              boardWinners[a] === boardWinners[c]
            ) {
              foundWinner = true;
              gameWinner = boardWinners[a];
              winningCombination = combo;
              break;
            }
          }
          if (!foundWinner) {
            gameWinner = 'tie';
            winningCombination = null;
            endGame();
          } else {
            endGame();
          }
        }
      }

      // Draw winning line on a board - fixed positioning for better centering
      function drawWinningLine(boardIndex, combo) {
        const board = document.querySelector(
          `.board[data-index="${boardIndex}"]`,
        );
        const boardRect = board.getBoundingClientRect();
        const cellSize = boardRect.width / 3;

        // Get positions of the winning cells
        const [a, b, c] = combo;
        const aCol = a % 3;
        const aRow = Math.floor(a / 3);
        const cCol = c % 3;
        const cRow = Math.floor(c / 3);

        // Calculate start and end points
        let startX, startY, endX, endY;

        // For rows - ensure horizontal lines are centered vertically in each row
        if (aRow === cRow) {
          // offset
          let rowOffset = -5;
          if (cRow == 0) rowOffset = -1.5;
          else if (cRow == 2) rowOffset = -9;

          startX = cellSize * 0.1; // Small offset from left edge

          // Calculate the exact center of the row
          startY = aRow * cellSize + cellSize / 2 + rowOffset;

          endX = boardRect.width - cellSize * 0.1 - 6; // Small offset from right edge
          endY = startY;
        }
        // For columns - ensure vertical lines are centered horizontally in each column
        else if (aCol === cCol) {
          // offset
          let colOffset = -3;
          if (cCol == 0) colOffset = 1;
          else if (cCol == 2) colOffset = -6;
          // Calculate the exact center of the column
          startX = aCol * cellSize + cellSize / 2 + colOffset;

          startY = cellSize * 0.1 - 1; // Small offset from top edge
          endX = startX;
          endY = boardRect.height - cellSize * 0.1 - 8.5; // Small offset from bottom edge
        }
        // For diagonals - keep the current implementation as requested
        else {
          if (a === 0 || c === 0) {
            // Top-left to bottom-right diagonal
            startX = cellSize * 0.1 + 2;
            startY = cellSize * 0.1 - 0; // Shifted up at start
            endX = boardRect.width - cellSize + 395 * 0.1 + 1;
            endY = boardRect.height - cellSize + 395 * 0.1 - 1; // Shifted up more at end
          } else {
            // Top-right to bottom-left diagonal
            startX = boardRect.width - cellSize * 0.1 - 8;
            startY = cellSize * 0.1 + 0; // Shifted up at start
            endX = cellSize * 0.1 + 2;
            endY = boardRect.height - cellSize * 0.1 - 10; // Shifted up more at end
          }
        }

        // Create the line element
        const line = document.createElement('div');
        line.className = 'winning-line';
        line.style.width = `${Math.sqrt(
          Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2),
        )}px`;
        line.style.height = '4px'; // line thickness
        line.style.left = `${startX}px`;
        line.style.top = `${startY}px`;
        line.style.transform = `rotate(${Math.atan2(endY - startY, endX - startX)}rad)`;
        line.style.transformOrigin = '0 50%'; // Center the line vertically
        line.style.backgroundColor =
          boardWinners[boardIndex] === 'x'
            ? gameSettings.xColor
            : gameSettings.oColor;

        board.appendChild(line);
      }

      // Update which boards are active and highlight them
      function updateActiveBoards() {
        document.querySelectorAll('.board').forEach(board => {
          board.classList.remove('active');
          board.querySelectorAll('.cell:not(.occupied)').forEach(cell => {
            cell.style.cursor = 'default';
          });
        });
        if (!gameActive || gameWinner) {
          return;
        }
        let activeBoardIndexes = [];
        if (activeBoard === null) {
          boardWinners.forEach((winner, index) => {
            if (winner === '') {
              activeBoardIndexes.push(index);
            }
          });
        } else {
          if (boardWinners[activeBoard] === '') {
            activeBoardIndexes.push(activeBoard);
          } else {
            boardWinners.forEach((winner, index) => {
              if (winner === '') {
                activeBoardIndexes.push(index);
              }
            });
          }
        }
        activeBoardIndexes.forEach(index => {
          const boardElement = document.querySelector(
            `.board[data-index="${index}"]`,
          );
          if (boardElement) {
            boardElement.classList.add('active');
            boardElement
              .querySelectorAll('.cell:not(.occupied)')
              .forEach(cell => {
                cell.style.cursor = 'pointer';
              });
          }
        });
      }

      // --- AI Logic ---

      // Find the best cell index within a specific board for 'O'
      function findBestMove(boardIndex) {
        const board = boards[boardIndex];
        const availableCells = [];
        for (let i = 0; i < 9; i++) {
          if (board[i] === '') availableCells.push(i);
        }
        if (availableCells.length === 0) return -1;
        for (const cellIndex of availableCells) {
          // Check AI win
          const tempBoard = [...board];
          tempBoard[cellIndex] = 'o';
          if (checkTempBoardWinner(tempBoard) === 'o') return cellIndex;
        }
        if (gameSettings.difficulty !== 'easy') {
          // Check block human win
          for (const cellIndex of availableCells) {
            const tempBoard = [...board];
            tempBoard[cellIndex] = 'x';
            if (checkTempBoardWinner(tempBoard) === 'x') return cellIndex;
          }
        }
        if (gameSettings.difficulty !== 'easy') {
          // Prioritize center/corners/sides
          const center = 4;
          if (availableCells.includes(center)) return center;
          const corners = [0, 2, 6, 8];
          const availableCorners = corners.filter(c =>
            availableCells.includes(c),
          );
          if (availableCorners.length > 0)
            return availableCorners[
              Math.floor(Math.random() * availableCorners.length)
            ];
          const sides = [1, 3, 5, 7];
          const availableSides = sides.filter(s => availableCells.includes(s));
          if (availableSides.length > 0)
            return availableSides[
              Math.floor(Math.random() * availableSides.length)
            ];
        }
        return availableCells[
          Math.floor(Math.random() * availableCells.length)
        ]; // Random fallback
      }

      // AI 'O' makes a move
      function aiMakeMove() {
        if (!gameActive || gameWinner || currentPlayer !== 'o') return;
        let boardIndex, cellIndex;
        const isHard = gameSettings.difficulty === 'hard';
        const canPlayAnywhere =
          activeBoard === null || boardWinners[activeBoard] !== '';

        if (isHard) {
          const bestOverallMove = findBestOverallMove('o');
          if (canPlayAnywhere) {
            boardIndex = bestOverallMove.board;
            cellIndex = bestOverallMove.cell;
          } else {
            boardIndex = activeBoard;
            cellIndex = findBestMoveWithScoring(boardIndex, 'o');
          }
        } else {
          if (canPlayAnywhere) {
            const availableBoards = [];
            for (let i = 0; i < 9; i++) {
              if (boardWinners[i] === '') availableBoards.push(i);
            }
            if (availableBoards.length === 0) return;
            let moveFound = false;
            for (const b of availableBoards) {
              // Check O win
              const bestCell = findBestMove(b);
              const tempBoard = [...boards[b]];
              tempBoard[bestCell] = 'o';
              if (checkTempBoardWinner(tempBoard) === 'o') {
                boardIndex = b;
                cellIndex = bestCell;
                moveFound = true;
                break;
              }
            }
            if (!moveFound && gameSettings.difficulty !== 'easy') {
              // Check X block
              for (const b of availableBoards) {
                const tempBoard = [...boards[b]]; // Need to check all cells for potential block
                for (let c = 0; c < 9; c++) {
                  if (tempBoard[c] === '') {
                    const blockTestBoard = [...tempBoard];
                    blockTestBoard[c] = 'x';
                    if (checkTempBoardWinner(blockTestBoard) === 'x') {
                      boardIndex = b;
                      cellIndex = c; // Found the cell to block
                      moveFound = true;
                      break;
                    }
                  }
                }
                if (moveFound) break;
              }
            }
            if (!moveFound) {
              // Random/Medium fallback
              boardIndex =
                availableBoards[
                  Math.floor(Math.random() * availableBoards.length)
                ];
              cellIndex = findBestMove(boardIndex);
            }
          } else {
            boardIndex = activeBoard;
            cellIndex = findBestMove(boardIndex);
          }
        }

        if (
          typeof boardIndex !== 'undefined' &&
          typeof cellIndex !== 'undefined' &&
          cellIndex !== -1 &&
          boards[boardIndex][cellIndex] === ''
        ) {
          makeMove(boardIndex, cellIndex, 'o');
        } else {
          console.error("AI 'O' failed to find a valid move.", {
            boardIndex,
            cellIndex,
            activeBoard,
            canPlayAnywhere,
          });
          const allAvailable = [];
          for (let b = 0; b < 9; b++) {
            if (boardWinners[b] === '') {
              for (let c = 0; c < 9; c++) {
                if (boards[b][c] === '') allAvailable.push({ b, c });
              }
            }
          }
          if (allAvailable.length > 0) {
            const randomFallback =
              allAvailable[Math.floor(Math.random() * allAvailable.length)];
            makeMove(randomFallback.b, randomFallback.c, 'o');
            console.log("AI 'O' made a random fallback move.");
          } else {
            console.error("AI 'O' fallback failed: No available cells found.");
          }
        }
        aiThinking.classList.remove('show');
      }

      // --- Hard AI Helper Functions ---

      // Evaluate if placing 'player' in board 'b', cell 'c' would win the super board
      function doesMoveWinSuperBoard(b, c, player) {
        const tempBoardWinners = [...boardWinners];
        tempBoardWinners[b] = player;
        return checkSuperBoardWin(tempBoardWinners) !== null;
      }

      // Check if a potential super board state wins
      function checkSuperBoardWin(boardState) {
        const winningCombos = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8],
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8],
          [0, 4, 8],
          [2, 4, 6],
        ];
        for (const combo of winningCombos) {
          const [a, b, c] = combo;
          if (
            boardState[a] &&
            boardState[a] !== 'tie' &&
            boardState[a] === boardState[b] &&
            boardState[a] === boardState[c]
          ) {
            return combo; // Return the winning combo
          }
        }
        return null; // No winner
      }

      // Score a potential move (boardIndex, cellIndex) for 'player'
      function scoreMove(boardIndex, cellIndex, player) {
        const opponent = player === 'x' ? 'o' : 'x';
        let score = 0;
        const tempBoard = [...boards[boardIndex]];
        tempBoard[cellIndex] = player;
        const boardResult = checkTempBoardWinner(tempBoard);

        if (boardResult === player) {
          // 1. Check board win
          score += 1000;
          if (doesMoveWinSuperBoard(boardIndex, cellIndex, player)) {
            score += 10000;
          } // Check game win
        }
        const tempOpponentBoard = [...boards[boardIndex]];
        tempOpponentBoard[cellIndex] = opponent;
        if (checkTempBoardWinner(tempOpponentBoard) === opponent) {
          // 2. Check block opponent board win
          score += 800;
          const tempOpponentWinsBoard = [...boardWinners];
          tempOpponentWinsBoard[boardIndex] = opponent;
          if (checkSuperBoardWin(tempOpponentWinsBoard)) {
            score += 5000;
          } // Check block opponent game win
        }

        const targetBoardIndex = cellIndex; // 3. Impact on next board
        if (boardWinners[targetBoardIndex] === '') {
          let opponentCanWinTarget = false;
          let weCanWinTarget = false;
          for (let i = 0; i < 9; i++) {
            if (boards[targetBoardIndex][i] === '') {
              const targetTestOpponent = [...boards[targetBoardIndex]];
              targetTestOpponent[i] = opponent;
              if (checkTempBoardWinner(targetTestOpponent) === opponent) {
                opponentCanWinTarget = true;
              }
              const targetTestPlayer = [...boards[targetBoardIndex]];
              targetTestPlayer[i] = player;
              if (checkTempBoardWinner(targetTestPlayer) === player) {
                weCanWinTarget = true;
              }
            }
          }
          if (opponentCanWinTarget) score -= 900;
          if (weCanWinTarget) score += 700;
          let playerPieces = 0;
          let opponentPieces = 0;
          boards[targetBoardIndex].forEach(cell => {
            if (cell === player) playerPieces++;
            else if (cell === opponent) opponentPieces++;
          });
          if (opponentPieces > playerPieces) score -= 50;
          else if (playerPieces > opponentPieces) score += 50;
        } else {
          // Sending to completed board
          if (
            !(
              boardResult === player &&
              doesMoveWinSuperBoard(boardIndex, cellIndex, player)
            ) &&
            !(
              checkTempBoardWinner(tempOpponentBoard) === opponent &&
              checkSuperBoardWin([...boardWinners, { [boardIndex]: opponent }])
            )
          ) {
            score -= 200;
          }
        }

        if (cellIndex === 4) score += 20;
        else if ([0, 2, 6, 8].includes(cellIndex)) score += 10; // 4. Cell value
        score += Math.random() * 5; // 5. Randomness
        return score;
      }

      // Find the best move (board, cell) across *all* available boards using scoring
      function findBestOverallMove(player) {
        let bestScore = -Infinity;
        let bestMoves = [];
        const availableBoards = [];
        boardWinners.forEach((w, i) => {
          if (w === '') availableBoards.push(i);
        });
        if (availableBoards.length === 0) {
          console.error(
            `findBestOverallMove called for ${player} but no available boards!`,
          );
          return { board: -1, cell: -1 };
        }
        for (const b of availableBoards) {
          for (let c = 0; c < 9; c++) {
            if (boards[b][c] === '') {
              const currentScore = scoreMove(b, c, player);
              if (currentScore > bestScore) {
                bestScore = currentScore;
                bestMoves = [{ board: b, cell: c }];
              } else if (currentScore === bestScore) {
                bestMoves.push({ board: b, cell: c });
              }
            }
          }
        }
        if (bestMoves.length === 0) {
          console.error(
            `findBestOverallMove for ${player} failed to find any scored move.`,
          );
          for (const b of availableBoards) {
            for (let c = 0; c < 9; c++) {
              if (boards[b][c] === '') return { board: b, cell: c };
            }
          }
          return { board: -1, cell: -1 };
        }
        return bestMoves[Math.floor(Math.random() * bestMoves.length)];
      }

      // Find the best move within a *specific* forced board using scoring
      function findBestMoveWithScoring(boardIndex, player) {
        let bestScore = -Infinity;
        let bestMoves = [];
        const availableCells = [];
        for (let c = 0; c < 9; c++) {
          if (boards[boardIndex][c] === '') {
            availableCells.push(c);
            const currentScore = scoreMove(boardIndex, c, player);
            if (currentScore > bestScore) {
              bestScore = currentScore;
              bestMoves = [c];
            } else if (currentScore === bestScore) {
              bestMoves.push(c);
            }
          }
        }
        if (bestMoves.length === 0) {
          console.error(
            `findBestMoveWithScoring for board ${boardIndex}, player ${player} found no moves.`,
          );
          if (availableCells.length > 0) {
            return availableCells[
              Math.floor(Math.random() * availableCells.length)
            ];
          }
          return -1;
        }
        return bestMoves[Math.floor(Math.random() * bestMoves.length)];
      }

      // --- Settings Modal Logic ---
      function showSettings() {
        // Remove 'aivsai' option if it exists dynamically (or ensure it's hidden by default CSS/HTML)
        const aiVsAiOption = document
          .getElementById('aiVsAi')
          ?.closest('.setting-option');
        if (aiVsAiOption) aiVsAiOption.style.display = 'none';

        // Populate the modal with current settings (ensure gameMode defaults if loaded pref was invalid)
        if (!['human', 'ai'].includes(gameSettings.gameMode))
          gameSettings.gameMode = 'ai';
        document.querySelector(
          `input[name="gameMode"][value="${gameSettings.gameMode}"]`,
        ).checked = true;
        document.querySelector(
          `input[name="rules"][value="${gameSettings.rules}"]`,
        ).checked = true;
        document.querySelector(
          `input[name="difficulty"][value="${gameSettings.difficulty}"]`,
        ).checked = true;
        xColorPicker.value = gameSettings.xColor;
        oColorPicker.value = gameSettings.oColor;
        xColorPicker.style.backgroundColor = gameSettings.xColor;
        oColorPicker.style.backgroundColor = gameSettings.oColor;
        aiDifficultyGroup.style.display =
          gameSettings.gameMode === 'human' ? 'none' : 'block';
        settingsModal.classList.add('show');
      }

      function hideSettings() {
        settingsModal.classList.remove('show');
      }

      function saveGameSettings() {
        // Read settings from the modal form
        let selectedGameMode = document.querySelector(
          'input[name="gameMode"]:checked',
        )?.value;
        // Fallback if somehow the removed AIvAI option is still checked
        if (!['human', 'ai'].includes(selectedGameMode))
          selectedGameMode = 'ai';

        const selectedRules = document.querySelector(
          'input[name="rules"]:checked',
        ).value;
        const selectedDifficulty = document.querySelector(
          'input[name="difficulty"]:checked',
        ).value;
        const selectedXColor = xColorPicker.value;
        const selectedOColor = oColorPicker.value;

        // Save previous settings to detect changes
        const prevGameMode = gameSettings.gameMode;
        const prevRules = gameSettings.rules;

        // Update the gameSettings object
        gameSettings.gameMode = selectedGameMode;
        gameSettings.rules = selectedRules;
        gameSettings.difficulty = selectedDifficulty;
        gameSettings.xColor = selectedXColor;
        gameSettings.oColor = selectedOColor;

        // Apply color/icon changes immediately
        updateColors();

        // Hide the settings modal
        hideSettings();

        // Save settings to localStorage
        localStorage.setItem(
          'ticTacSquaredPreferences',
          JSON.stringify(gameSettings),
        );

        // If there's an active game, apply changes dynamically
        if (gameActive && !gameWinner) {
          // If rules changed, update which boards are active
          if (prevRules !== selectedRules) {
            if (selectedRules === 'free') {
              // Free play - any non-won board is valid
              activeBoard = null;
            } else if (lastMove.cellIndex !== -1) {
              // Standard - use the cell index from last move to determine next active board
              activeBoard =
                boardWinners[lastMove.cellIndex] === ''
                  ? lastMove.cellIndex
                  : null;
            }
            updateActiveBoards();
          }

          // If game mode changed, handle the transition smoothly
          if (prevGameMode !== selectedGameMode) {
            // Handle transition from human mode to AI mode
            if (
              prevGameMode === 'human' &&
              selectedGameMode === 'ai' &&
              currentPlayer === 'o'
            ) {
              // If it's O's turn now and we switched to AI mode, trigger AI move
              aiThinking.classList.add('show');
              if (pendingAIMove !== null) {
                clearTimeout(pendingAIMove);
              }
              pendingAIMove = setTimeout(() => {
                pendingAIMove = null;
                if (!gameActive || gameWinner) {
                  aiThinking.classList.remove('show');
                  return;
                }
                aiMakeMove();
              }, 800);
            }
            // Handle transition from AI mode to human mode
            else if (prevGameMode === 'ai' && selectedGameMode === 'human') {
              // Cancel any pending AI moves
              if (pendingAIMove !== null) {
                clearTimeout(pendingAIMove);
                pendingAIMove = null;
              }
              aiThinking.classList.remove('show');
            }
          }

          // Save the current game state with updated settings
          saveGameState();
        }
      }

      // --- How To Play Modal ---
      function showHowToPlay() {
        howToPlayModal.classList.add('show');
      }
      function hideHowToPlay() {
        howToPlayModal.classList.remove('show');
      }

      // --- Modal Outside Click Listener Setup ---
      function setupModalOutsideClickListeners() {
        const modals = [settingsModal, howToPlayModal, coinFlipModal];
        modals.forEach(modal => {
          if (modal) {
            modal.addEventListener('click', event => {
              if (event.target === modal) {
                const closeButton = modal.querySelector(
                  '#cancelSettings, #closeHowToPlayBtn',
                );
                if (modal === coinFlipModal) {
                } // Don't close coin flip
                else if (closeButton) {
                  closeButton.click();
                } else {
                  modal.classList.remove('show');
                }
              }
            });
          }
        });
      }

      // --- Event Listeners ---
      document.addEventListener('DOMContentLoaded', () => {
        setupModalOutsideClickListeners();
        howToPlayBtn.addEventListener('click', showHowToPlay);
        closeHowToPlayBtn.addEventListener('click', hideHowToPlay);
        newGameBtn.addEventListener('click', () => {
          initGame();
        });
        playAgainBtn.addEventListener('click', initGame);
        viewBoardBtn.addEventListener('click', () =>
          gameOver.classList.remove('show'),
        );
        settingsBtn.addEventListener('click', showSettings);
        cancelSettings.addEventListener('click', hideSettings);
        saveSettings.addEventListener('click', saveGameSettings);

        xColorPicker.addEventListener('input', event => {
          const newColor = event.target.value;
          document.documentElement.style.setProperty('--x-color', newColor);
          playerXDisplay.style.color = newColor;
          xColorPicker.style.backgroundColor = newColor;
        });
        oColorPicker.addEventListener('input', event => {
          const newColor = event.target.value;
          document.documentElement.style.setProperty('--o-color', newColor);
          playerODisplay.style.color = newColor;
          oColorPicker.style.backgroundColor = newColor;
        });

        resetXColorBtn.addEventListener('click', e => {
          e.preventDefault();
          xColorPicker.value = DEFAULT_X_COLOR;
          xColorPicker.dispatchEvent(new Event('input'));
          xColorPicker.style.backgroundColor = DEFAULT_X_COLOR;
        });
        resetOColorBtn.addEventListener('click', e => {
          e.preventDefault();
          oColorPicker.value = DEFAULT_O_COLOR;
          oColorPicker.dispatchEvent(new Event('input'));
          oColorPicker.style.backgroundColor = DEFAULT_O_COLOR;
        });

        // Settings: Show/hide AI difficulty when game mode changes
        humanVsHumanRadio.addEventListener('change', () => {
          if (humanVsHumanRadio.checked)
            aiDifficultyGroup.style.display = 'none';
        });
        humanVsAIRadio.addEventListener('change', () => {
          if (humanVsAIRadio.checked) aiDifficultyGroup.style.display = 'block';
        });
        // Removed listener for aiVsAiRadio

        // --- Game Initialization ---
        loadPreferences(); // Load saved settings first
        if (!loadGameState()) {
          // Try loading saved game state
          initGame(); // If no saved game, start a fresh one
        }
      });
    </script>
  </body>
</html>
