<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tic Tac Squared</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <!-- PeerJS library -->
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <style>
      /* --- Base Styles (Mostly Unchanged) --- */
      :root {
        --x-color: #ff4757;
        --o-color: #1e90ff;
        --bg-color: #2f3542;
        --board-bg: #57606f;
        --highlight: rgba(255, 255, 255, 0.1);
        --text-light: #f1f2f6;
        --modal-bg: rgba(47, 53, 66, 0.95);
        --disabled-color: #747d8c;
        --error-color: #ff6b6b;
        --success-color: #2ecc71;
        --code-prefix: 'TTSQ-'; /* Internal prefix for PeerJS IDs */
      }

      body {
        margin: 0;
        padding: 0;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-light);
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        position: relative;
      }

      header {
        text-align: center;
        margin-top: 10px;
        margin-bottom: 5px;
        width: 100%;
        position: relative;
      }

      h1 {
        font-size: 2.9rem;
        margin-bottom: 10px;
        color: white;
      }

      .game-info {
        display: flex;
        justify-content: space-around;
        align-items: center;
        width: 550px;
        max-width: 95%;
        margin: 0 auto 15px;
        font-size: 1.2rem;
        font-weight: bold;
        min-height: 50px;
        flex-wrap: wrap; /* Allow wrapping if needed */
        gap: 10px; /* Add gap for wrapping */
      }

      .player {
        padding: 10px 15px;
        border-radius: 5px;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 8px;
        flex-shrink: 0;
      }

      .player.active {
        background-color: var(--highlight);
        box-shadow: 0 0 8px currentColor;
      }

      .player.inactive {
        opacity: 0.6;
      }

      .player-x {
        color: var(--x-color);
      }

      .player-o {
        color: var(--o-color);
      }

      #gameCodeDisplay {
        font-size: 1.2rem; /* Larger code */
        font-weight: bold;
        letter-spacing: 2px; /* Space out chars */
        background-color: var(--board-bg);
        padding: 8px 16px; /* More padding */
        border-radius: 5px;
        cursor: pointer;
        border: 1px solid var(--text-light);
        transition: all 0.2s ease;
        text-align: center;
        display: none; /* Hidden by default */
        white-space: nowrap;
        order: 0; /* Keep code between players if space allows */
        flex-basis: 150px; /* Give it some base width */
        flex-grow: 0;
      }

      #gameCodeDisplay:hover {
        background-color: var(--highlight);
        border-color: white;
      }

      #gameCodeDisplay .copy-icon {
        margin-left: 8px;
        font-size: 0.9em;
        opacity: 0.7;
      }

      #gameCodeDisplay.copied::after {
        content: ' Copied!';
        font-size: 0.8em;
        color: var(--success-color);
        margin-left: 5px;
        animation: fadeOut 1.5s forwards;
      }

      @keyframes fadeOut {
        to {
          opacity: 0;
        }
      }

      .super-board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        gap: 10px;
        width: 500px;
        height: 500px;
        margin: 0 auto;
        position: relative;
      }

      .board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        gap: 5px;
        background-color: var(--board-bg);
        border-radius: 8px;
        padding: 5px;
        position: relative;
        overflow: hidden;
        transition:
          box-shadow 0.3s,
          background-color 0.3s,
          border-color 0.3s,
          opacity 0.3s;
      }

      .board.active {
        box-shadow: 0 0 0 3px var(--text-light);
        animation: pulse 1.5s infinite;
      }

      .board.won-x {
        background-color: rgba(255, 71, 87, 0.2);
        border: 3px solid var(--x-color);
      }
      .board.won-o {
        background-color: rgba(30, 144, 255, 0.2);
        border: 3px solid var(--o-color);
      }
      .board.tie {
        background-color: rgba(113, 128, 147, 0.5);
        border: 3px solid var(--text-light);
      }
      .board.inactive-board {
        opacity: 0.5;
        pointer-events: none;
      }

      .cell {
        background-color: var(--bg-color);
        border-radius: 4px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 24px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
        position: relative;
        z-index: 2;
      }
      .cell:hover:not(.occupied):not(.disabled-cell) {
        background-color: var(--highlight);
      }
      .cell.occupied,
      .cell.disabled-cell {
        cursor: default;
      }
      .cell.x {
        color: var(--x-color);
      }
      .cell.o {
        color: var(--o-color);
      }
      .cell.last-move::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: currentColor;
        opacity: 0.15;
        pointer-events: none;
        border-radius: 4px;
      }

      .winning-line {
        position: absolute;
        background-color: rgba(255, 255, 255, 0.8);
        z-index: 5;
        transform-origin: 0 0;
      }

      .controls {
        margin-top: 20px;
        margin-bottom: 20px;
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        justify-content: center;
      }

      button {
        padding: 10px 20px;
        background-color: var(--board-bg);
        color: var(--text-light);
        border: none;
        border-radius: 5px;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 8px;
        border: 1px solid rgba(255, 255, 255, 0.3);
      }
      button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        border-color: rgba(255, 255, 255, 0.8);
      }
      button:disabled {
        background-color: var(--disabled-color);
        cursor: not-allowed;
        opacity: 0.7;
        border-color: rgba(0, 0, 0, 0.2);
        transform: none;
        box-shadow: none;
      }

      .status-display {
        /* Shared style for AI Thinking / Connection Status */
        font-style: italic;
        transition: opacity 0.3s;
        display: flex;
        align-items: center;
        justify-content: center; /* Center content */
        gap: 8px;
        font-size: 1rem;
        color: var(--text-light);
        min-height: 25px; /* Ensure space */
        text-align: center;
        order: 0; /* Keep between players */
        flex-basis: 200px; /* Allow space */
        flex-grow: 1; /* Allow to grow */
        opacity: 0; /* Hidden by default */
        pointer-events: none; /* Don't capture clicks */
      }
      .status-display.show {
        opacity: 1;
      }
      #aiThinking {
        /* Inherits from status-display */
      }
      #connectionStatus {
        /* Inherits from status-display */
      }

      .game-over {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.85); /* Darker overlay */
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s;
      }
      .game-over.show {
        opacity: 1;
        pointer-events: all;
      }
      .game-over-message {
        font-size: 3rem;
        font-weight: bold;
        margin-bottom: 25px;
        text-align: center;
      }
      .game-over-message.x {
        color: var(--x-color);
      }
      .game-over-message.o {
        color: var(--o-color);
      }
      .game-over-message.tie {
        color: var(--text-light);
      }
      .game-over-buttons {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        justify-content: center;
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 3px var(--text-light);
        }
        50% {
          box-shadow: 0 0 0 6px var(--text-light);
        }
        100% {
          box-shadow: 0 0 0 3px var(--text-light);
        }
      }

      /* --- Modal Styles (Improved) --- */
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--modal-bg);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 200;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease-out;
      }
      .modal.show {
        opacity: 1;
        pointer-events: all;
      }

      .modal-content {
        background-color: var(--board-bg);
        padding: 30px 35px; /* More padding */
        border-radius: 12px; /* Softer radius */
        width: 450px; /* Default width */
        max-width: 90%;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.4);
        position: relative;
        border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 25px;
      }
      .modal-title {
        font-size: 1.7rem;
        margin: 0;
        font-weight: 600;
      }
      .modal-close-btn {
        background: none;
        border: none;
        color: var(--text-light);
        font-size: 1.8rem;
        cursor: pointer;
        padding: 0 5px;
        line-height: 1;
        opacity: 0.7;
        transition: opacity 0.2s;
      }
      .modal-close-btn:hover {
        opacity: 1;
      }
      .modal-footer {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
        margin-top: 30px;
      }

      /* Start Menu */
      #startMenuModal .modal-content {
        text-align: center;
        width: 400px;
      }
      #startMenuModal .modal-footer {
        justify-content: center;
        flex-direction: column;
        gap: 15px;
      }
      #startMenuModal button {
        width: 100%;
        font-size: 1.1rem;
        padding: 12px;
      }

      /* Online Menu */
      #onlineMenuModal .modal-content {
        width: 480px;
      }
      .online-menu-section {
        margin-bottom: 25px;
        padding-bottom: 20px;
        border-bottom: 1px solid var(--highlight);
      }
      .online-menu-section:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
      }
      #onlineMenuModal label {
        display: block;
        margin-bottom: 10px;
        font-weight: 600;
        font-size: 1.1rem;
      }
      #onlineMenuModal input[type='text'] {
        width: 100%;
        padding: 12px 15px;
        border-radius: 6px;
        border: 1px solid var(--highlight);
        background-color: var(--bg-color);
        color: var(--text-light);
        font-size: 1.1rem;
        box-sizing: border-box;
        margin-bottom: 12px;
        text-align: center;
        letter-spacing: 2px;
        text-transform: uppercase;
      }
      #onlineMenuModal input[type='text']::placeholder {
        text-transform: none;
        letter-spacing: normal;
      }
      #onlineMenuModal .modal-footer {
        justify-content: space-between;
      }
      #statusMessage {
        margin-top: 20px;
        font-style: normal;
        min-height: 22px;
        font-weight: 500;
        text-align: center;
        transition: color 0.3s;
      }
      #statusMessage.error {
        color: var(--error-color);
      }
      #statusMessage.success {
        color: var(--success-color);
      }
      .loader {
        border: 4px solid var(--highlight);
        border-top: 4px solid var(--text-light);
        border-radius: 50%;
        width: 18px;
        height: 18px;
        animation: spin 1s linear infinite;
        display: inline-block;
        margin-left: 10px;
        vertical-align: middle;
        display: none; /* Hidden initially */
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      /* Style for Create Game button when creating */
      #createGameBtn.creating {
        font-style: italic;
      }

      /* Settings Modal */
      #settingsModal .modal-content {
        width: 550px;
      }
      .settings-columns {
        display: flex;
        gap: 30px;
      }
      .settings-column {
        flex: 1;
      }
      .setting-group {
        margin-bottom: 20px;
      }
      .setting-label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
      }
      .setting-option {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }
      .setting-option input {
        margin-right: 10px;
      }
      .color-picker {
        display: flex;
        gap: 25px;
        margin-top: 15px;
        flex-wrap: wrap;
      }
      .color-option {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .color-box {
        width: 35px;
        height: 35px;
        border-radius: 50%;
        cursor: pointer;
        border: 2px solid transparent;
        transition: transform 0.2s;
        background-color: transparent;
        -webkit-appearance: none;
        appearance: none;
        padding: 0;
        overflow: hidden;
        vertical-align: middle;
      }
      input[type='color']::-moz-color-swatch {
        border: none;
        border-radius: 50%;
      }
      input[type='color']::-webkit-color-swatch-wrapper {
        padding: 0;
        border-radius: 50%;
      }
      input[type='color']::-webkit-color-swatch {
        border: none;
        border-radius: 50%;
      }
      .settings-footer {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 30px;
      }
      #aiDifficultyGroup {
        display: none;
      } /* Hidden by default, shown by JS */
      .reset-color-btn {
        background: none;
        border: none;
        color: var(--text-light);
        cursor: pointer;
        padding: 5px;
        border-radius: 50%;
        font-size: 0.9rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        margin-left: 5px;
      }
      .reset-color-btn:hover {
        background-color: var(--highlight);
        transform: rotate(-45deg);
      }

      /* Coin Flip Modal */
      .coin-flip-modal {
        /* Use .modal base style */
      }
      .coin-flip-content {
        background-color: var(--board-bg);
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        max-width: 90%;
      }
      .coin {
        width: 100px;
        height: 100px;
        margin: 20px auto;
        position: relative;
        transform-style: preserve-3d;
        transition: transform 0.1s;
      }
      .coin.flipping {
        animation: flip-coin 1.5s ease-out forwards;
      }
      .coin-side {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        backface-visibility: hidden;
        font-size: 2.5rem;
        font-weight: bold;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      }
      .coin-side.heads {
        background: linear-gradient(45deg, #ffd700, #ffcc00);
        border: 4px solid #e6b800;
        color: var(--x-color);
        z-index: 2;
      }
      .coin-side.tails {
        background: linear-gradient(45deg, #ffd700, #ffcc00);
        border: 4px solid #e6b800;
        color: var(--o-color);
        transform: rotateY(180deg);
      }
      @keyframes flip-coin {
        0% {
          transform: rotateY(0) rotateX(0);
        }
        20% {
          transform: rotateY(180deg) rotateX(720deg);
        }
        40% {
          transform: rotateY(360deg) rotateX(1440deg);
        }
        60% {
          transform: rotateY(540deg) rotateX(2160deg);
        }
        80% {
          transform: rotateY(720deg) rotateX(2880deg);
        }
        100% {
          transform: rotateY(900deg) rotateX(3600deg);
        }
      }

      /* How To Play Modal */
      .how-to-play-modal {
        /* Use .modal base style */
      }
      .how-to-play-content {
        background-color: var(--board-bg);
        padding: 30px;
        border-radius: 10px;
        width: 600px;
        max-width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      }
      .how-to-play-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      .how-to-play-title {
        font-size: 1.5rem;
        margin: 0;
      }
      .how-to-play-body {
        margin-bottom: 20px;
      }
      .how-to-play-body h3 {
        margin-top: 16px;
        margin-bottom: 8px;
        color: var(--text-light);
      }
      .how-to-play-body p,
      .how-to-play-body li {
        margin-bottom: 8px;
        line-height: 1.5;
      }
      .how-to-play-footer {
        display: flex;
        justify-content: center;
      }

      /* Media Queries */
      @media (max-width: 600px) {
        .super-board {
          width: 95vw;
          height: 95vw;
          gap: 5px;
        }
        h1 {
          font-size: 2rem;
          margin-bottom: 5px;
        }
        .game-info {
          width: 95vw;
          font-size: 1rem;
          flex-direction: row;
          justify-content: space-between;
          gap: 5px;
          min-height: 0;
        }
        .player {
          padding: 6px 10px;
          font-size: 0.9rem;
          gap: 5px;
        }
        #gameCodeDisplay {
          font-size: 1rem;
          padding: 6px 10px;
          letter-spacing: 1px;
          order: 1;
          flex-basis: auto;
          margin-top: 5px;
        } /* Center code below players on small screens */
        .status-display {
          order: 1;
          flex-basis: 100%;
          font-size: 0.9rem;
          margin-top: 5px;
        }
        .controls {
          width: 95vw;
          gap: 10px;
          margin-top: 15px;
          margin-bottom: 15px;
        }
        .controls button {
          font-size: 0.9rem;
          padding: 8px 15px;
        }
        .game-over-message {
          font-size: 2rem;
          margin-bottom: 20px;
        }
        .game-over-buttons {
          flex-direction: column;
          width: 80%;
          gap: 10px;
        }
        .game-over-buttons button {
          width: 100%;
        }
        .modal-content {
          padding: 20px;
        }
        .modal-title {
          font-size: 1.4rem;
        }
        .settings-columns {
          flex-direction: column;
          gap: 0;
        }
        .color-picker {
          justify-content: center;
          gap: 15px;
        }
        #onlineMenuModal input[type='text'] {
          font-size: 1rem;
          padding: 10px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Tic Tac Squared</h1>
      <div class="game-info">
        <div class="player player-x active">
          <span class="player-role">You</span>
          <i class="fas fa-times fa-lg"></i>
        </div>
        <!-- Status/Code Display Area -->
        <div id="gameCodeDisplay">
          <span id="codeValue"></span> <i class="far fa-copy copy-icon"></i>
        </div>
        <div id="aiThinking" class="status-display">
          AI thinking... <i class="fas fa-cog fa-spin"></i>
        </div>
        <div id="connectionStatus" class="status-display">
          Connecting... <i class="fas fa-spinner fa-spin"></i>
        </div>
        <div class="player player-o">
          <span class="player-role">AI</span>
          <i class="far fa-circle"></i>
        </div>
      </div>
    </header>

    <div id="superBoard" class="super-board"></div>

    <!-- Start Menu Modal -->
    <div class="modal" id="startMenuModal">
      <div class="modal-content">
        <div class="modal-header">
          <h3 class="modal-title">Choose Game Mode</h3>
          <!-- No close button needed here -->
        </div>
        <div class="modal-footer">
          <button id="playLocallyBtn">
            <i class="fas fa-users"></i> Play Locally
          </button>
          <button id="playOnlineBtn">
            <i class="fas fa-globe"></i> Play Online
          </button>
        </div>
      </div>
    </div>

    <!-- Online Menu Modal -->
    <div class="modal" id="onlineMenuModal">
      <div class="modal-content">
        <div class="modal-header">
          <h3 class="modal-title">Play Online</h3>
          <button
            class="modal-close-btn"
            id="closeOnlineMenuBtn"
            aria-label="Close">
            &times;
          </button>
        </div>
        <div class="online-menu-section">
          <button
            id="createGameBtn"
            style="width: 100%; padding: 12px; font-size: 1.1rem">
            <i class="fas fa-plus-circle"></i> Create New Game
          </button>
        </div>
        <div class="online-menu-section">
          <label for="gameCodeInput">Enter 5-Character Game Code:</label>
          <input
            type="text"
            id="gameCodeInput"
            placeholder="ABCDE"
            maxlength="5" />
          <button
            id="joinGameBtn"
            style="width: 100%; padding: 12px; font-size: 1.1rem">
            <i class="fas fa-sign-in-alt"></i> Join Game
          </button>
        </div>
        <div id="statusMessage">
          Initializing... <span class="loader"></span>
        </div>
      </div>
    </div>

    <!-- Settings Modal (Structure remains the same) -->
    <div class="modal" id="settingsModal">
      <div class="modal-content">
        <div class="modal-header">
          <h3 class="modal-title">Local Game Settings</h3>
          <button
            class="modal-close-btn"
            id="cancelSettings"
            aria-label="Close">
            &times;
          </button>
        </div>
        <div class="settings-columns">
          <div class="settings-column">
            <div class="setting-group">
              <label class="setting-label">Game Mode:</label>
              <div class="setting-option">
                <input
                  type="radio"
                  id="humanVsHuman"
                  name="gameMode"
                  value="human" /><label for="humanVsHuman"
                  >Human vs Human</label
                >
              </div>
              <div class="setting-option">
                <input
                  type="radio"
                  id="humanVsAI"
                  name="gameMode"
                  value="ai"
                  checked /><label for="humanVsAI">Human vs AI</label>
              </div>
            </div>
          </div>
          <div class="settings-column">
            <div class="setting-group" id="aiDifficultyGroup">
              <label class="setting-label">AI Difficulty:</label>
              <div class="setting-option">
                <input
                  type="radio"
                  id="easyAI"
                  name="difficulty"
                  value="easy" /><label for="easyAI">Easy</label>
              </div>
              <div class="setting-option">
                <input
                  type="radio"
                  id="mediumAI"
                  name="difficulty"
                  value="medium"
                  checked /><label for="mediumAI">Medium</label>
              </div>
              <div class="setting-option">
                <input
                  type="radio"
                  id="hardAI"
                  name="difficulty"
                  value="hard" /><label for="hardAI">Hard</label>
              </div>
            </div>
          </div>
        </div>
        <div class="setting-group">
          <label class="setting-label">Rules:</label>
          <div class="setting-option">
            <input
              type="radio"
              id="standardRules"
              name="rules"
              value="standard"
              checked /><label for="standardRules"
              >Standard (next board determined by last move)</label
            >
          </div>
          <div class="setting-option">
            <input
              type="radio"
              id="freeRules"
              name="rules"
              value="free" /><label for="freeRules"
              >Free Play (move in any board at any time)</label
            >
          </div>
        </div>
        <div class="setting-group">
          <label class="setting-label">Player Colors:</label>
          <div class="color-picker">
            <div class="color-option">
              <label>X Color</label
              ><input
                type="color"
                id="xColorPicker"
                class="color-box"
                value="#ff4757" /><button
                class="reset-color-btn"
                id="resetXColor">
                <i class="fas fa-undo-alt"></i>
              </button>
            </div>
            <div class="color-option">
              <label>O Color</label
              ><input
                type="color"
                id="oColorPicker"
                class="color-box"
                value="#1e90ff" /><button
                class="reset-color-btn"
                id="resetOColor">
                <i class="fas fa-undo-alt"></i>
              </button>
            </div>
          </div>
        </div>
        <div class="settings-footer">
          <button id="saveSettings">
            <i class="fas fa-save"></i> Save & Close
          </button>
          <!-- Cancel button moved to header -->
        </div>
      </div>
    </div>

    <!-- Coin Flip Modal (Structure remains the same) -->
    <div class="modal coin-flip-modal" id="coinFlipModal">
      <div class="coin-flip-content">
        <h2>Flip a Coin</h2>
        <p>Determining who goes first...</p>
        <div class="coin" id="coin">
          <div class="coin-side heads"><i class="fas fa-times fa-2x"></i></div>
          <div class="coin-side tails"><i class="far fa-circle fa-2x"></i></div>
        </div>
        <div id="coinResult"></div>
      </div>
    </div>

    <!-- How To Play Modal (Structure remains the same) -->
    <div class="modal how-to-play-modal" id="howToPlayModal">
      <div class="how-to-play-content">
        <div class="how-to-play-header">
          <h3 class="how-to-play-title">How to Play</h3>
          <button
            class="modal-close-btn"
            id="closeHowToPlayBtn"
            aria-label="Close">
            &times;
          </button>
        </div>
        <div class="how-to-play-body">
          <!-- Content -->
          <h3>Basic Rules</h3>
          <ul>
            <li>Players take turns marking spaces with X or O.</li>
            <li>Win a small board by getting three of your marks in a row.</li>
            <li>
              Win the game by winning three small boards in a row on the super
              board.
            </li>
          </ul>
          <h3>Board Selection Rules</h3>
          <p>
            <strong>Standard Rules:</strong> Your move sends your opponent to
            the corresponding board.
          </p>
          <p>
            <strong>Free Play:</strong> Players can play in any non-completed
            board on their turn.
          </p>
          <h3>Special Situations</h3>
          <ul>
            <li>
              If you're sent to a board that's already won or tied, you can play
              in any available board.
            </li>
            <li>A tied board doesn't count for either player.</li>
          </ul>
        </div>
        <div class="how-to-play-footer">
          <!-- Close button moved to header -->
        </div>
      </div>
    </div>

    <div class="controls">
      <button id="howToPlayBtn">
        <i class="fas fa-question-circle"></i> How to Play
      </button>
      <button id="settingsBtn"><i class="fas fa-cog"></i> Settings</button>
      <button id="newGameBtn">
        <i class="fas fa-plus-circle"></i> New Game
      </button>
      <button id="quitOnlineBtn" style="display: none">
        <i class="fas fa-sign-out-alt"></i> Quit Game
      </button>
    </div>

    <div class="game-over" id="gameOver">
      <div id="gameOverMessage" class="game-over-message"></div>
      <div class="game-over-buttons">
        <button id="playAgainBtn">
          <i class="fas fa-sync-alt"></i> Play Again
        </button>
        <button id="viewBoardBtn"><i class="fas fa-eye"></i> View Board</button>
        <button id="goToMenuBtn"><i class="fas fa-bars"></i> Main Menu</button>
      </div>
    </div>

    <script>
      // --- DOM Elements ---
      const superBoard = document.getElementById('superBoard');
      const playerXDisplay = document.querySelector('.player-x');
      const playerODisplay = document.querySelector('.player-o');
      const playerXRole = playerXDisplay.querySelector('.player-role');
      const playerORole = playerODisplay.querySelector('.player-role');
      const gameCodeDisplay = document.getElementById('gameCodeDisplay');
      const codeValueSpan = document.getElementById('codeValue');
      const aiThinking = document.getElementById('aiThinking');
      const connectionStatus = document.getElementById('connectionStatus');
      const howToPlayBtn = document.getElementById('howToPlayBtn');
      const newGameBtn = document.getElementById('newGameBtn');
      const quitOnlineBtn = document.getElementById('quitOnlineBtn');
      const gameOver = document.getElementById('gameOver');
      const gameOverMessage = document.getElementById('gameOverMessage');
      const playAgainBtn = document.getElementById('playAgainBtn');
      const viewBoardBtn = document.getElementById('viewBoardBtn');
      const goToMenuBtn = document.getElementById('goToMenuBtn');
      const settingsBtn = document.getElementById('settingsBtn');
      const settingsModal = document.getElementById('settingsModal');
      const saveSettings = document.getElementById('saveSettings');
      const cancelSettings = document.getElementById('cancelSettings'); // Now in modal header
      const humanVsHumanRadio = document.getElementById('humanVsHuman');
      const humanVsAIRadio = document.getElementById('humanVsAI');
      const aiDifficultyGroup = document.getElementById('aiDifficultyGroup');
      const coinFlipModal = document.getElementById('coinFlipModal');
      const coin = document.getElementById('coin');
      const coinResult = document.getElementById('coinResult');
      const xColorPicker = document.getElementById('xColorPicker');
      const oColorPicker = document.getElementById('oColorPicker');
      const resetXColorBtn = document.getElementById('resetXColor');
      const resetOColorBtn = document.getElementById('resetOColor');
      const howToPlayModal = document.getElementById('howToPlayModal');
      const closeHowToPlayBtn = document.getElementById('closeHowToPlayBtn'); // Now in modal header

      // Menu Modals & Elements
      const startMenuModal = document.getElementById('startMenuModal');
      const onlineMenuModal = document.getElementById('onlineMenuModal');
      const playLocallyBtn = document.getElementById('playLocallyBtn');
      const playOnlineBtn = document.getElementById('playOnlineBtn');
      const closeOnlineMenuBtn = document.getElementById('closeOnlineMenuBtn');
      const createGameBtn = document.getElementById('createGameBtn');
      const gameCodeInput = document.getElementById('gameCodeInput');
      const joinGameBtn = document.getElementById('joinGameBtn');
      const statusMessage = document.getElementById('statusMessage');
      const statusLoader = statusMessage.querySelector('.loader');

      // --- Constants ---
      const DEFAULT_X_COLOR = '#ff4757';
      const DEFAULT_O_COLOR = '#1e90ff';
      const PEER_ID_PREFIX = 'TTSQ-'; // Prefix for PeerJS IDs to make them somewhat unique
      const SHORT_CODE_LENGTH = 5;
      const SHORT_CODE_CHARS = 'ABCDEFGHIJKLMNPQRSTUVWXYZ123456789'; // Exclude O, 0
      const MAX_CREATE_ATTEMPTS = 5; // Max attempts for generating a unique short code

      // --- Game State ---
      let gameModeType = 'menu'; // 'menu', 'local', 'online'
      let currentPlayer = ''; // 'x' or 'o'
      let activeBoard = null; // Board index (0-8) or null (any)
      let boards = [];
      let boardWinners = [];
      let gameWinner = '';
      let gameActive = false;
      let winningCombination = null;
      let lastMove = { boardIndex: -1, cellIndex: -1, player: '' };
      let pendingAIMove = null;

      // Local Game Settings
      let gameSettings = {
        gameMode: 'ai',
        rules: 'standard',
        xColor: DEFAULT_X_COLOR,
        oColor: DEFAULT_O_COLOR,
        difficulty: 'medium',
      };

      // Online Game State
      let peer = null;
      let conn = null;
      let shortGameCode = null; // The 5-char code visible to users
      let fullPeerId = null; // The actual ID used by PeerJS (prefix + code)
      let playerSymbolOnline = null;
      let isOnlineGame = false;
      let isConnecting = false; // Flag to prevent multiple connection attempts
      let createAttemptCount = 0; // Counter for creation attempts

      // --- Helper Functions ---

      function showModal(modalElement) {
        modalElement.classList.add('show');
      }

      function hideModal(modalElement) {
        modalElement.classList.remove('show');
      }

      function hexToRGBA(hex, alpha) {
        /* ... (same as before) ... */
        if (!hex || hex.length < 7) hex = '#000000';
        try {
          let r = parseInt(hex.slice(1, 3), 16),
            g = parseInt(hex.slice(3, 5), 16),
            b = parseInt(hex.slice(5, 7), 16);
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        } catch (error) {
          return `rgba(0, 0, 0, ${alpha})`;
        }
      }

      function generateShortCode() {
        let result = '';
        for (let i = 0; i < SHORT_CODE_LENGTH; i++) {
          result += SHORT_CODE_CHARS.charAt(
            Math.floor(Math.random() * SHORT_CODE_CHARS.length),
          );
        }
        return result;
      }

      function updateStatusDisplay(
        element,
        message,
        showSpinner = false,
        isError = false,
        isSuccess = false,
      ) {
        if (!element) return;
        element.innerHTML = `${message} ${showSpinner ? '<i class="fas fa-spinner fa-spin"></i>' : ''}`;
        element.classList.toggle('show', !!message);
        element.classList.toggle('error', isError); // Add error class if needed
        element.classList.toggle('success', isSuccess); // Add success class if needed

        // Ensure only one status is shown prominently
        if (element === connectionStatus && message) {
          aiThinking.classList.remove('show');
          gameCodeDisplay.style.display = 'none';
        } else if (element === aiThinking && message) {
          connectionStatus.classList.remove('show');
          gameCodeDisplay.style.display = 'none';
        }
      }

      function updateOnlineMenuStatus(
        message,
        showSpinner = false,
        isError = false,
        isSuccess = false,
      ) {
        statusMessage.innerHTML = `${message} ${showSpinner ? '<span class="loader" style="display:inline-block"></span>' : ''}`;
        statusMessage.className =
          `status-message ${isError ? 'error' : ''} ${isSuccess ? 'success' : ''}`.trim(); // Apply classes
      }

      function copyToClipboard(text) {
        /* ... (same as before) ... */
        navigator.clipboard
          .writeText(text)
          .then(() => {
            gameCodeDisplay.classList.add('copied');
            setTimeout(() => gameCodeDisplay.classList.remove('copied'), 1500);
          })
          .catch(err => {
            console.error('Failed to copy game code: ', err);
            alert('Failed to copy code. Please copy it manually.');
          });
      }

      // --- Initialization and Menu Logic ---

      function showStartMenu() {
        gameModeType = 'menu';
        isOnlineGame = false;
        gameActive = false;
        isConnecting = false;
        cleanupPeer();
        hideModal(onlineMenuModal);
        hideModal(settingsModal);
        hideModal(howToPlayModal);
        hideModal(coinFlipModal); // Use hideModal for consistency
        gameOver.classList.remove('show');
        superBoard.innerHTML = '';
        playerXDisplay.classList.remove('active', 'inactive');
        playerODisplay.classList.remove('active', 'inactive');
        gameCodeDisplay.style.display = 'none';
        updateStatusDisplay(connectionStatus, ''); // Clear connection status
        updateStatusDisplay(aiThinking, ''); // Clear AI status
        settingsBtn.style.display = 'inline-flex';
        newGameBtn.innerHTML = '<i class="fas fa-plus-circle"></i> New Game'; // Reset button text/icon
        quitOnlineBtn.style.display = 'none';
        createGameBtn.disabled = false; // Re-enable buttons
        joinGameBtn.disabled = false;
        createGameBtn.classList.remove('creating');
        loadPreferences();
        updateColors();
        showModal(startMenuModal);
      }

      function initLocalGame() {
        /* ... (same as before, uses coin flip) ... */
        gameModeType = 'local';
        isOnlineGame = false;
        hideModal(startMenuModal);
        hideModal(settingsModal);

        resetGameState();
        loadPreferences();
        updateColors();
        createBoardUI();

        showModal(coinFlipModal); // Use showModal
        flipCoin();
      }

      function initOnlineMode() {
        gameModeType = 'online'; // Tentative
        isOnlineGame = true; // Mark as online attempt
        hideModal(startMenuModal);
        showModal(onlineMenuModal);
        updateOnlineMenuStatus('Initializing...', true);
        createGameBtn.disabled = true;
        joinGameBtn.disabled = true;
        initializePeer(); // Initialize PeerJS for online play
      }

      // --- PeerJS Logic (Revised) ---

      function initializePeer(idToUse = null, isCreating = false) {
        if (peer && !peer.destroyed && peer.id === idToUse) {
          console.log('Peer already initialized with this ID:', idToUse);
          if (isCreating) {
            // If trying to create with existing peer
            updateOnlineMenuStatus(
              `Ready. Waiting for opponent... Code: ${shortGameCode}`,
              false,
              false,
              true,
            );
            createGameBtn.disabled = true; // Stay disabled
            joinGameBtn.disabled = true;
            hideModal(onlineMenuModal);
            displayShortCode(); // Show code in header
          } else {
            // If trying to join with existing peer (less likely scenario)
            updateOnlineMenuStatus('Ready. Enter code to join.', false);
            createGameBtn.disabled = false;
            joinGameBtn.disabled = false;
          }
          return; // Don't re-initialize
        }

        cleanupPeer(); // Clean up previous peer/connection first

        try {
          console.log(
            `Initializing Peer ${idToUse ? 'with ID: ' + idToUse : 'with random ID'}`,
          );
          peer = new Peer(idToUse, {
            // debug: 2 // Uncomment for verbose PeerJS logging
          });

          peer.on('open', id => {
            fullPeerId = id; // Store the actual ID assigned by the server
            console.log('PeerJS connection open. Actual ID:', fullPeerId);
            isConnecting = false; // No longer in the process of connecting Peer itself

            if (isCreating) {
              // Successfully created the peer with the desired prefixed ID
              createAttemptCount = 0; // Reset attempt counter
              updateOnlineMenuStatus(
                `Waiting for opponent... Code: ${shortGameCode}`,
                false,
                false,
                true,
              );
              createGameBtn.disabled = true; // Keep disabled while waiting
              joinGameBtn.disabled = true; // Can't join while hosting
              createGameBtn.classList.remove('creating');
              hideModal(onlineMenuModal); // Hide modal, show code in header
              displayShortCode();
            } else {
              // Initialized PeerJS successfully (likely for joining, or first load)
              updateOnlineMenuStatus(
                'Ready. Create a game or enter code to join.',
                false,
              );
              createGameBtn.disabled = false;
              joinGameBtn.disabled = false;
            }
          });

          peer.on('connection', incomingConn => {
            console.log('Incoming connection attempt from:', incomingConn.peer);
            if (conn && conn.open) {
              console.warn(
                'Already connected to a peer. Rejecting new connection.',
              );
              incomingConn.on('open', () => {
                // Wait for their channel to open to send rejection
                incomingConn.send({ type: 'error', message: 'Host is busy' });
                setTimeout(() => incomingConn.close(), 500);
              });
              return;
            }
            if (isConnecting) {
              // If we are currently trying to connect *out*, reject incoming
              console.warn(
                'Currently attempting to connect out. Rejecting incoming connection.',
              );
              incomingConn.on('open', () => {
                incomingConn.send({
                  type: 'error',
                  message: 'Host is busy connecting',
                });
                setTimeout(() => incomingConn.close(), 500);
              });
              return;
            }

            console.log('Accepting connection from:', incomingConn.peer);
            conn = incomingConn;
            isConnecting = false; // No longer trying to connect out

            // ---- Host side: Setup connection events FIRST ----
            conn.on('open', () => {
              console.log('Data connection open with', conn.peer);
              // NOW it's safe to send initial data
              playerSymbolOnline = 'x'; // Host is always X
              startGameOnline(); // Set up local board for host

              // Send assignment and initial state
              sendData({
                type: 'assignSymbol',
                symbol: 'o', // Assign O to joiner
                initialState: {
                  currentPlayer: currentPlayer, // Should be 'x'
                  activeBoard: activeBoard,
                  boardWinners: boardWinners,
                  boards: boards,
                  rules: gameSettings.rules,
                  xColor: gameSettings.xColor,
                  oColor: gameSettings.oColor,
                },
              });
              updateStatusDisplay(connectionStatus, ''); // Clear "Waiting..." message
              updateOnlinePlayerUI(); // Update player displays
            });

            setupCommonConnectionEvents(); // Setup data, close, error handlers
          });

          peer.on('disconnected', () => {
            console.warn('Peer disconnected from signaling server.');
            // PeerJS attempts to reconnect automatically. Only intervene if game was active.
            if (isOnlineGame && gameActive) {
              updateStatusDisplay(
                connectionStatus,
                'Connection lost. Attempting to reconnect...',
                true,
              );
            } else if (isOnlineGame && !conn) {
              // If disconnected while waiting for opponent
              updateStatusDisplay(
                connectionStatus,
                'Signaling server disconnected. Please try creating again.',
                false,
                true,
              );
              // Consider going back to menu automatically after a delay
              setTimeout(showStartMenu, 4000);
            }
          });

          peer.on('close', () => {
            console.log('Peer instance destroyed.');
            // Don't call handleDisconnection here, it's called when conn closes or error occurs
            if (!conn && isOnlineGame) {
              // If peer closed before a connection was made
              handleDisconnection('Connection failed (Peer closed).');
            }
          });

          peer.on('error', err => {
            console.error('PeerJS Error:', err.type, err);
            isConnecting = false; // Stop connection attempts on error
            createGameBtn.classList.remove('creating');
            let userMessage = `Connection Error (${err.type})`;
            let isFatal = false;

            switch (err.type) {
              case 'browser-incompatible':
                userMessage = 'Browser not supported for online play.';
                isFatal = true;
                break;
              case 'disconnected':
                // Usually handled by 'disconnected' event, but can happen here too
                userMessage = 'Disconnected from signaling server.';
                break;
              case 'network':
                userMessage = 'Network error. Check connection & firewall.';
                break;
              case 'peer-unavailable':
                userMessage = 'Opponent not found. Check the code.';
                break;
              case 'server-error':
                userMessage = 'Signaling server error. Please try again later.';
                break;
              case 'socket-error':
                userMessage = 'Connection error (socket). Try again.';
                break;
              case 'socket-closed':
                userMessage = 'Connection closed unexpectedly.';
                break;
              case 'unavailable-id':
                userMessage = `Game code ${shortGameCode} is already in use.`;
                if (isCreating && createAttemptCount < MAX_CREATE_ATTEMPTS) {
                  console.log(
                    `ID unavailable, attempt ${createAttemptCount + 1}. Retrying...`,
                  );
                  createAttemptCount++;
                  // Automatically try creating with a new code
                  createOnlineGame(true); // Pass true to indicate retry
                  return; // Prevent further status updates for this error
                } else if (isCreating) {
                  userMessage += ' Please try creating again.';
                  createAttemptCount = 0; // Reset counter after max attempts
                }
                break;
              case 'webrtc':
                userMessage =
                  'WebRTC connection error. May be blocked by network.';
                break;
              default:
                userMessage = `Unknown connection error: ${err.type}`;
            }

            // Show error in the appropriate place
            if (onlineMenuModal.classList.contains('show')) {
              updateOnlineMenuStatus(userMessage, false, true); // Show error in modal
              createGameBtn.disabled = false; // Re-enable buttons
              joinGameBtn.disabled = false;
            } else if (isOnlineGame && gameActive) {
              handleDisconnection(userMessage); // Handle as a disconnection during game
            } else if (isOnlineGame) {
              // Error during connection phase after modal closed
              updateStatusDisplay(connectionStatus, userMessage, false, true);
              setTimeout(showStartMenu, 4000); // Go back to menu after showing error
            }

            if (isFatal) {
              // Disable online play buttons if browser is incompatible
              playOnlineBtn.disabled = true;
              playOnlineBtn.title = 'Browser not supported';
              createGameBtn.disabled = true;
              joinGameBtn.disabled = true;
            }
          });
        } catch (error) {
          console.error('Failed to initialize PeerJS:', error);
          updateOnlineMenuStatus(
            'Fatal Error initializing connection. Please refresh.',
            false,
            true,
          );
          isConnecting = false;
          createGameBtn.disabled = true;
          joinGameBtn.disabled = true;
        }
      }

      function createOnlineGame(isRetry = false) {
        if (isConnecting) return; // Prevent multiple attempts

        if (!isRetry) {
          createAttemptCount = 0; // Reset counter for fresh attempts
          shortGameCode = generateShortCode();
        } else {
          shortGameCode = generateShortCode(); // Generate a new code for retry
        }
        fullPeerId = PEER_ID_PREFIX + shortGameCode;

        console.log(
          `Attempting to create game with code: ${shortGameCode} (Peer ID: ${fullPeerId})`,
        );
        isConnecting = true; // Mark as trying to establish peer connection
        createGameBtn.disabled = true;
        joinGameBtn.disabled = true;
        createGameBtn.classList.add('creating');
        updateOnlineMenuStatus(
          `Creating game with code ${shortGameCode}...`,
          true,
        );

        initializePeer(fullPeerId, true); // Initialize PeerJS with the specific ID
      }

      function joinOnlineGame() {
        const enteredCode = gameCodeInput.value.trim().toUpperCase();
        if (enteredCode.length !== SHORT_CODE_LENGTH) {
          updateOnlineMenuStatus(
            `Please enter a ${SHORT_CODE_LENGTH}-character code.`,
            false,
            true,
          );
          return;
        }
        if (!peer || peer.disconnected || peer.destroyed) {
          updateOnlineMenuStatus(
            'Not connected to signaling server. Re-initializing...',
            true,
            true,
          );
          initializePeer(); // Try to re-initialize before connecting
          setTimeout(joinOnlineGame, 1500); // Retry joining after re-init attempt
          return;
        }
        if (conn || isConnecting) {
          console.log('Already connecting or connected.');
          return;
        }

        const targetPeerId = PEER_ID_PREFIX + enteredCode;
        console.log(
          'Attempting to connect to:',
          enteredCode,
          `(Peer ID: ${targetPeerId})`,
        );
        isConnecting = true;
        createGameBtn.disabled = true;
        joinGameBtn.disabled = true;
        updateOnlineMenuStatus(`Connecting to game ${enteredCode}...`, true);

        try {
          conn = peer.connect(targetPeerId, { reliable: true });
          if (!conn) {
            throw new Error('peer.connect returned null');
          }

          // --- Joiner side: Setup connection events ---
          conn.on('open', () => {
            console.log('Data connection open with host:', targetPeerId);
            isConnecting = false; // Successfully initiated connection
            // Now wait for the host to send the 'assignSymbol' message
            updateStatusDisplay(
              connectionStatus,
              'Connected! Waiting for game data...',
              true,
            );
            hideModal(onlineMenuModal); // Hide menu, show status in header
          });

          setupCommonConnectionEvents(); // Setup data, close, error handlers
        } catch (err) {
          console.error('Failed to initiate connection:', err);
          updateOnlineMenuStatus(
            `Failed to connect. Check code or network.`,
            false,
            true,
          );
          isConnecting = false;
          createGameBtn.disabled = false; // Re-enable buttons on failure
          joinGameBtn.disabled = false;
        }
      }

      // Sets up the common handlers (data, close, error) for the DataConnection
      function setupCommonConnectionEvents() {
        if (!conn) return;

        conn.on('data', data => {
          console.log('Received data:', data);
          handleReceivedData(data);
        });

        conn.on('close', () => {
          console.log('Connection closed.');
          handleDisconnection('Opponent disconnected.');
        });

        conn.on('error', err => {
          console.error('Connection Error:', err);
          handleDisconnection(`Connection error: ${err.type || 'Unknown'}`);
        });
      }

      function displayShortCode() {
        codeValueSpan.textContent = shortGameCode || 'Error';
        gameCodeDisplay.style.display = 'inline-flex';
        updateStatusDisplay(connectionStatus, ''); // Clear status once code is shown
      }

      function handleReceivedData(data) {
        // Ignore data if connection isn't considered active or game ended
        if (
          !isOnlineGame ||
          (!gameActive && data.type !== 'assignSymbol' && data.type !== 'error')
        ) {
          console.warn(
            'Ignoring data received while connection/game is inactive:',
            data.type,
          );
          return;
        }

        switch (data.type) {
          case 'assignSymbol':
            // Joiner receives this after conn.on('open')
            if (playerSymbolOnline) {
              console.warn('Received assignSymbol multiple times?');
              return; // Avoid resetting state if already assigned
            }
            playerSymbolOnline = data.symbol;
            gameSettings.rules = data.initialState.rules;
            gameSettings.xColor = data.initialState.xColor;
            gameSettings.oColor = data.initialState.oColor;
            updateColors();

            // Load initial state from host
            currentPlayer = data.initialState.currentPlayer;
            activeBoard = data.initialState.activeBoard;
            boards = data.initialState.boards;
            boardWinners = data.initialState.boardWinners;
            gameActive = true; // Game is now officially active
            isConnecting = false; // Ensure connecting flag is false

            createBoardUI(); // Create board structure
            recreateGameUI(); // Populate with received state
            updateStatusDisplay(connectionStatus, ''); // Clear status message
            updateOnlinePlayerUI();
            console.log(
              `Assigned symbol: ${playerSymbolOnline}. Game starting.`,
            );
            break;

          case 'move':
            // Received opponent's move
            const opponentSymbol = playerSymbolOnline === 'x' ? 'o' : 'x';
            if (currentPlayer !== opponentSymbol) {
              console.warn("Received move but it's not opponent's turn.");
              // Optional: Request resync? For now, ignore.
              return;
            }
            if (!isValidMove(data.boardIndex, data.cellIndex)) {
              console.error('Received invalid move from opponent:', data);
              // Optional: Send error back or request resync?
              sendData({ type: 'error', message: 'Invalid move received' });
              return;
            }
            makeMove(data.boardIndex, data.cellIndex, opponentSymbol);
            break;

          case 'gameOver':
            // Opponent declared game over (likely because *their* move caused it)
            // We trust the opponent's calculation for simplicity here,
            // but a robust system might verify the win condition locally.
            if (gameActive) {
              // Only process if game is still considered active locally
              gameWinner = data.winner;
              winningCombination = data.winningCombination;
              gameActive = false;
              updateBoardUI(); // Update board states visually based on received winner
              displayEndGameMessage(); // Display result based on received winner
              gameOver.classList.add('show');
              updateOnlinePlayerUI(); // Update active state
            }
            break;

          case 'quit':
            handleDisconnection('Opponent quit the game.');
            break;

          case 'error':
            console.error('Received error message from peer:', data.message);
            if (
              data.message === 'Host is busy' ||
              data.message === 'Host is busy connecting'
            ) {
              updateOnlineMenuStatus(
                data.message + '. Please try again later.',
                false,
                true,
              );
              setTimeout(showStartMenu, 3000);
            } else {
              // Handle other potential errors if needed
              updateStatusDisplay(
                connectionStatus,
                `Opponent Error: ${data.message}`,
                false,
                true,
              );
            }
            cleanupPeer(); // Disconnect on receiving error
            break;

          default:
            console.warn('Received unknown data type:', data.type);
        }
      }

      function sendData(data) {
        if (conn && conn.open) {
          conn.send(data);
        } else {
          console.warn('Cannot send data, connection not open or available.', {
            connOpen: conn?.open,
          });
          // Avoid calling handleDisconnection directly here, as it might be a temporary issue
          // The close/error handlers on the connection should manage disconnections.
          // Maybe show a temporary warning?
          // updateStatusDisplay(connectionStatus, "Cannot send data - connection issue?", false, true);
        }
      }

      function handleDisconnection(reason) {
        if (!isOnlineGame) return; // Only handle for online games

        console.log('Handling disconnection:', reason);
        const wasGameActive = gameActive; // Store if game was running before cleanup
        gameActive = false; // Mark game as inactive

        if (wasGameActive) {
          // Game was in progress, the remaining player wins
          gameWinner = playerSymbolOnline || 'tie'; // Assign win to current player, or tie if symbol unknown
          winningCombination = null; // No line for disconnect/error
          displayEndGameMessage(
            `${reason}. You ${gameWinner === playerSymbolOnline ? 'win' : 'lose'}!`,
          );
          gameOver.classList.add('show');
        } else if (!gameOver.classList.contains('show')) {
          // Game wasn't active, show status (unless game over screen already shown)
          updateStatusDisplay(connectionStatus, reason, false, true); // Show reason as error
          // Go back to menu after delay if connection failed before game start
          setTimeout(showStartMenu, 4000);
        }

        cleanupPeer(); // Clean up PeerJS objects
        updateOnlinePlayerUI(); // Clear active states
        quitOnlineBtn.style.display = 'none';
        newGameBtn.innerHTML = '<i class="fas fa-plus-circle"></i> New Game';
        settingsBtn.style.display = 'inline-flex';
        isConnecting = false; // Reset connection flag
      }

      function cleanupPeer() {
        console.log('Cleaning up PeerJS connection...');
        if (conn) {
          conn.off('data'); // Remove listeners
          conn.off('open');
          conn.off('close');
          conn.off('error');
          if (conn.open) {
            // Only close if it's open
            conn.close();
          }
          conn = null;
        }
        if (peer) {
          peer.off('open'); // Remove listeners
          peer.off('connection');
          peer.off('disconnected');
          peer.off('close');
          peer.off('error');
          if (!peer.destroyed) {
            peer.destroy();
          }
          peer = null;
        }
        shortGameCode = null;
        fullPeerId = null;
        playerSymbolOnline = null;
        // isOnlineGame should be reset by showStartMenu or when starting local game
      }

      // --- Game Start Logic ---

      function startGame(startingPlayer) {
        // Local game start
        /* ... (same as before) ... */
        currentPlayer = startingPlayer;
        gameActive = true;
        activeBoard = null;
        updateOnlinePlayerUI();
        updateActiveBoards();
        saveGameState(); // Save local state

        if (
          gameSettings.gameMode === 'ai' &&
          currentPlayer === 'o' &&
          !isOnlineGame
        ) {
          updateStatusDisplay(aiThinking, 'AI thinking...', true);
          pendingAIMove = setTimeout(() => {
            /* ... AI move logic ... */
            pendingAIMove = null;
            if (!gameActive || gameWinner) {
              updateStatusDisplay(aiThinking, '');
              return;
            }
            aiMakeMove();
          }, 800);
        }
      }

      function startGameOnline() {
        // Online game setup (called by host on conn open, joiner on receiving state)
        resetGameState();
        // Rules/Colors are synced via 'assignSymbol' data for joiner
        // Host uses their current settings initially
        updateColors();
        createBoardUI();

        // Host sets initial state, joiner gets it from data
        if (!playerSymbolOnline) playerSymbolOnline = 'x'; // Host default if called directly

        if (playerSymbolOnline === 'x') {
          // Host always starts
          currentPlayer = 'x';
        } else {
          // Joiner's state is set in handleReceivedData 'assignSymbol'
          // This function might be called *before* state is received when joiner UI is created
          if (!currentPlayer) currentPlayer = 'x'; // Assume x starts until state sync
        }

        gameActive = true;
        isOnlineGame = true; // Explicitly set
        isConnecting = false;
        activeBoard = null;
        updateOnlinePlayerUI();
        updateActiveBoards();

        settingsBtn.style.display = 'none';
        quitOnlineBtn.style.display = 'inline-flex';
        newGameBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Rematch?'; // Change button purpose online

        console.log(
          `Online game started/updated. You are ${playerSymbolOnline}. Turn: ${currentPlayer}`,
        );
      }

      // --- Board Creation and UI Updates ---

      function createBoardUI() {
        /* ... (same as before) ... */
        superBoard.innerHTML = '';
        document.querySelectorAll('.winning-line').forEach(el => el.remove());
        for (let i = 0; i < 9; i++) {
          const board = document.createElement('div');
          board.className = 'board';
          board.dataset.index = i;
          for (let j = 0; j < 9; j++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.board = i;
            cell.dataset.cell = j;
            cell.addEventListener('click', handleCellClick);
            board.appendChild(cell);
          }
          superBoard.appendChild(board);
        }
      }

      function recreateGameUI() {
        /* ... (same as before - populates from state) ... */
        createBoardUI(); // Ensure clean structure

        for (let i = 0; i < 9; i++) {
          for (let j = 0; j < 9; j++) {
            if (boards[i][j]) {
              const cell = document.querySelector(
                `.cell[data-board="${i}"][data-cell="${j}"]`,
              );
              if (cell) {
                cell.classList.add(boards[i][j], 'occupied');
                cell.innerHTML =
                  boards[i][j] === 'x'
                    ? '<i class="fas fa-times fa-lg"></i>'
                    : '<i class="far fa-circle"></i>';
                cell.style.color =
                  boards[i][j] === 'x'
                    ? gameSettings.xColor
                    : gameSettings.oColor;
                cell.style.cursor = 'default';
              }
            }
          }
          if (boardWinners[i]) {
            const winningCombo = findWinningCombo(i);
            updateBoardUI(i, winningCombo); // Update visual state + draw line
          }
        }

        updateOnlinePlayerUI();
        updateActiveBoards();

        if (gameWinner) {
          displayEndGameMessage();
          if (winningCombination && gameWinner !== 'tie') {
            setTimeout(() => drawSuperWinningLine(winningCombination), 100);
          }
          gameOver.classList.add('show');
          gameActive = false;
        } else if (!gameActive && currentPlayer) {
          updateOnlinePlayerUI();
          updateActiveBoards();
        }

        findAndHighlightLastMove();
      }

      function updateColors() {
        /* ... (same as before) ... */
        document.documentElement.style.setProperty(
          '--x-color',
          gameSettings.xColor,
        );
        document.documentElement.style.setProperty(
          '--o-color',
          gameSettings.oColor,
        );
        playerXDisplay.style.color = gameSettings.xColor;
        playerODisplay.style.color = gameSettings.oColor;
        if (xColorPicker) {
          xColorPicker.value = gameSettings.xColor;
          xColorPicker.style.backgroundColor = gameSettings.xColor;
        }
        if (oColorPicker) {
          oColorPicker.value = gameSettings.oColor;
          oColorPicker.style.backgroundColor = gameSettings.oColor;
        }
        document.querySelectorAll('.board.won-x').forEach(b => {
          b.style.borderColor = gameSettings.xColor;
          b.style.backgroundColor = hexToRGBA(gameSettings.xColor, 0.2);
        });
        document.querySelectorAll('.board.won-o').forEach(b => {
          b.style.borderColor = gameSettings.oColor;
          b.style.backgroundColor = hexToRGBA(gameSettings.oColor, 0.2);
        });
        document
          .querySelectorAll('.cell.x')
          .forEach(c => (c.style.color = gameSettings.xColor));
        document
          .querySelectorAll('.cell.o')
          .forEach(c => (c.style.color = gameSettings.oColor));
        // Update winning lines (ensure this is called after state updates)
        document.querySelectorAll('.winning-line').forEach(line => {
          const boardElement = line.closest('.board');
          if (boardElement) {
            const boardIndex = parseInt(boardElement.dataset.index);
            if (boardWinners[boardIndex] === 'x')
              line.style.backgroundColor = gameSettings.xColor;
            else if (boardWinners[boardIndex] === 'o')
              line.style.backgroundColor = gameSettings.oColor;
          } else if (
            superBoard.contains(line) &&
            gameWinner &&
            gameWinner !== 'tie'
          ) {
            line.style.backgroundColor =
              gameWinner === 'x' ? gameSettings.xColor : gameSettings.oColor;
          }
        });
        const coinHeads = document.querySelector('.coin-side.heads');
        if (coinHeads) coinHeads.style.color = gameSettings.xColor;
        const coinTails = document.querySelector('.coin-side.tails');
        if (coinTails) coinTails.style.color = gameSettings.oColor;
      }

      function updateOnlinePlayerUI() {
        /* ... (same as before - handles local/online display) ... */
        if (isOnlineGame) {
          playerXRole.textContent =
            playerSymbolOnline === 'x' ? 'You' : 'Opponent';
          playerORole.textContent =
            playerSymbolOnline === 'o' ? 'You' : 'Opponent';
          const isMyTurn = gameActive && currentPlayer === playerSymbolOnline;
          playerXDisplay.classList.toggle(
            'active',
            playerSymbolOnline === 'x' && isMyTurn,
          );
          playerODisplay.classList.toggle(
            'active',
            playerSymbolOnline === 'o' && isMyTurn,
          );
          playerXDisplay.classList.toggle(
            'inactive',
            gameActive && playerSymbolOnline === 'x' && !isMyTurn,
          );
          playerODisplay.classList.toggle(
            'inactive',
            gameActive && playerSymbolOnline === 'o' && !isMyTurn,
          );
          updateStatusDisplay(aiThinking, ''); // No AI
        } else {
          // Local
          playerXRole.textContent = 'Player X';
          playerORole.textContent =
            gameSettings.gameMode === 'human' ? 'Player O' : 'AI';
          playerXDisplay.querySelector('i:first-of-type').className =
            'fas fa-user';
          playerODisplay.querySelector('i:first-of-type').className =
            `fas ${gameSettings.gameMode === 'human' ? 'fa-user' : 'fa-robot'}`;
          playerXDisplay.classList.toggle(
            'active',
            gameActive && currentPlayer === 'x',
          );
          playerODisplay.classList.toggle(
            'active',
            gameActive && currentPlayer === 'o',
          );
          playerXDisplay.classList.remove('inactive');
          playerODisplay.classList.remove('inactive');
          // Show/Hide AI thinking status only if relevant
          aiThinking.classList.toggle(
            'show',
            gameActive &&
              !gameWinner &&
              gameSettings.gameMode === 'ai' &&
              currentPlayer === 'o',
          );
        }
        // Clear connection status if game is active or not online
        if (gameActive || !isOnlineGame) {
          updateStatusDisplay(connectionStatus, '');
        }
      }

      function updateActiveBoards() {
        /* ... (same as before, handles active/inactive styling) ... */
        document.querySelectorAll('.board').forEach(board => {
          board.classList.remove('active', 'inactive-board');
          board.style.boxShadow = ''; // Clear potential dimmed highlight
          board.style.animation = ''; // Clear pulse
          board.querySelectorAll('.cell').forEach(cell => {
            cell.style.cursor =
              boardWinners[board.dataset.index] ||
              boards[board.dataset.index][cell.dataset.cell]
                ? 'default'
                : 'pointer'; // Base cursor
            cell.classList.remove('disabled-cell');
          });
        });

        if (!gameActive || gameWinner) {
          if (gameWinner) {
            document.querySelectorAll('.board').forEach((board, index) => {
              if (!boardWinners[index]) board.classList.add('inactive-board');
            });
          }
          return;
        }

        let activeBoardIndexes = [];
        if (gameSettings.rules === 'standard' && activeBoard !== null) {
          if (boardWinners[activeBoard] === '') {
            activeBoardIndexes.push(activeBoard);
          } else {
            boardWinners.forEach((winner, index) => {
              if (winner === '') activeBoardIndexes.push(index);
            });
            activeBoard = null; // Update state to reflect free choice
          }
        } else {
          // Free play or start or sent to completed board
          boardWinners.forEach((winner, index) => {
            if (winner === '') activeBoardIndexes.push(index);
          });
          activeBoard = null; // Update state to reflect free choice
        }

        const isMyTurn = !isOnlineGame || currentPlayer === playerSymbolOnline;

        document.querySelectorAll('.board').forEach((boardElement, index) => {
          const isBoardActiveTarget = activeBoardIndexes.includes(index);
          const isBoardWon = !!boardWinners[index];

          if (isBoardActiveTarget && !isBoardWon) {
            if (isMyTurn) {
              boardElement.classList.add('active'); // Highlight playable boards for current player
              // Ensure animation restarts if needed
              boardElement.style.animation = 'pulse 1.5s infinite';
              boardElement
                .querySelectorAll('.cell:not(.occupied)')
                .forEach(cell => {
                  cell.style.cursor = 'pointer';
                });
            } else {
              // Opponent's turn: Show active target, but don't allow clicks
              boardElement.classList.add('active'); // Still show it's the target
              boardElement.style.boxShadow = '0 0 0 3px var(--disabled-color)'; // Dimmer highlight
              boardElement.querySelectorAll('.cell').forEach(cell => {
                // Disable all cells in opponent's active board
                cell.style.cursor = 'default';
                cell.classList.add('disabled-cell');
              });
            }
          } else if (!isBoardActiveTarget && !isBoardWon) {
            // Board is not the active target and not won/tied
            boardElement.classList.add('inactive-board'); // Dim it
            boardElement.querySelectorAll('.cell').forEach(cell => {
              cell.style.cursor = 'default';
              cell.classList.add('disabled-cell');
            });
          }
          // If board is won/tied, styling is handled by updateBoardUI
        });
      }

      // --- Game Logic ---

      function resetGameState() {
        /* ... (same as before) ... */
        currentPlayer = '';
        activeBoard = null;
        boards = Array(9)
          .fill()
          .map(() => Array(9).fill(''));
        boardWinners = Array(9).fill('');
        gameWinner = '';
        gameActive = false;
        winningCombination = null;
        lastMove = { boardIndex: -1, cellIndex: -1, player: '' };
        if (pendingAIMove) clearTimeout(pendingAIMove);
        pendingAIMove = null;
      }

      function isValidMove(boardIndex, cellIndex) {
        /* ... (same as before) ... */
        if (!gameActive || gameWinner) return false;
        if (boards[boardIndex]?.[cellIndex] !== '') return false;
        if (boardWinners[boardIndex] !== '') return false;

        let isValidBoard = false;
        if (activeBoard === null) {
          // Any playable board
          isValidBoard = boardWinners[boardIndex] === '';
        } else {
          // Specific board required
          isValidBoard = boardIndex === activeBoard;
        }
        // Allow playing anywhere if sent to completed board (standard rules)
        if (
          !isValidBoard &&
          gameSettings.rules === 'standard' &&
          activeBoard !== null &&
          boardWinners[activeBoard] !== ''
        ) {
          isValidBoard = boardWinners[boardIndex] === '';
        }
        return isValidBoard;
      }

      function handleCellClick(event) {
        /* ... (mostly same, ensure validation) ... */
        if (!gameActive || gameWinner || isConnecting) return;

        const cellElement = event.currentTarget;
        const boardIndex = parseInt(cellElement.dataset.board);
        const cellIndex = parseInt(cellElement.dataset.cell);

        let isMyTurn;
        if (isOnlineGame) {
          isMyTurn = currentPlayer === playerSymbolOnline;
        } else {
          isMyTurn =
            gameSettings.gameMode === 'human' ||
            (gameSettings.gameMode === 'ai' && currentPlayer === 'x');
        }

        if (!isMyTurn) {
          console.log('Not your turn.');
          return;
        }

        if (!isValidMove(boardIndex, cellIndex)) {
          console.log('Invalid move clicked.');
          cellElement.style.animation = 'shake 0.5s';
          setTimeout(() => (cellElement.style.animation = ''), 500);
          return;
        }

        // --- Make the Move Locally ---
        makeMove(boardIndex, cellIndex, currentPlayer); // Updates state and UI

        // --- Post-Move Actions ---
        if (isOnlineGame) {
          sendData({ type: 'move', boardIndex, cellIndex });
          if (gameWinner) {
            // Check if *my* move ended the game
            sendData({
              type: 'gameOver',
              winner: gameWinner,
              winningCombination: winningCombination,
            });
            // endGame() is called inside makeMove if gameWinner is set
          }
        } else {
          // Local Game
          if (gameWinner) {
            // endGame() called inside makeMove
          } else if (
            gameActive &&
            gameSettings.gameMode === 'ai' &&
            currentPlayer === 'o'
          ) {
            updateStatusDisplay(aiThinking, 'AI thinking...', true);
            if (pendingAIMove) clearTimeout(pendingAIMove);
            pendingAIMove = setTimeout(() => {
              /* ... AI move ... */
              pendingAIMove = null;
              if (!gameActive || gameWinner) {
                updateStatusDisplay(aiThinking, '');
                return;
              }
              aiMakeMove();
            }, 800);
          }
        }
      }

      function makeMove(boardIndex, cellIndex, player) {
        /* ... (same core logic) ... */
        if (!gameActive || gameWinner || boards[boardIndex]?.[cellIndex] !== '')
          return;

        boards[boardIndex][cellIndex] = player;

        // Update Last Move UI
        const lastCell = document.querySelector('.cell.last-move');
        if (lastCell) lastCell.classList.remove('last-move');
        const cell = document.querySelector(
          `.cell[data-board="${boardIndex}"][data-cell="${cellIndex}"]`,
        );
        if (cell) {
          cell.classList.add(player, 'occupied', 'last-move');
          cell.innerHTML =
            player === 'x'
              ? '<i class="fas fa-times fa-lg"></i>'
              : '<i class="far fa-circle"></i>';
          cell.style.color =
            player === 'x' ? gameSettings.xColor : gameSettings.oColor;
          cell.style.cursor = 'default';
        }
        lastMove = { boardIndex, cellIndex, player };

        // Check board win (mutates boardWinners)
        let oldBoardWinner = boardWinners[boardIndex];
        checkBoardWinner(boardIndex);
        if (
          boardWinners[boardIndex] !== oldBoardWinner &&
          boardWinners[boardIndex] !== ''
        ) {
          updateBoardUI(boardIndex, findWinningCombo(boardIndex)); // Update UI if board just completed
        }

        // Check game win (mutates gameWinner, gameActive)
        checkGameWinner();

        if (gameWinner) {
          endGame(); // Handle end game UI updates
          return; // Stop further processing
        }

        // If game continues, determine next state
        if (gameActive) {
          const nextPlayer = player === 'x' ? 'o' : 'x';
          let nextActiveBoard = null;
          if (gameSettings.rules === 'standard') {
            nextActiveBoard = boardWinners[cellIndex] === '' ? cellIndex : null;
          } // else: free play, nextActiveBoard remains null

          currentPlayer = nextPlayer;
          activeBoard = nextActiveBoard;

          updateOnlinePlayerUI();
          updateActiveBoards();

          if (!isOnlineGame) saveGameState(); // Save local state
        }
      }

      function checkBoardWinner(boardIndex) {
        /* ... (same logic) ... */
        if (boardWinners[boardIndex] !== '') return;
        const boardState = boards[boardIndex];
        const winningCombos = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8],
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8],
          [0, 4, 8],
          [2, 4, 6],
        ];
        for (const combo of winningCombos) {
          const [a, b, c] = combo;
          if (
            boardState[a] &&
            boardState[a] === boardState[b] &&
            boardState[a] === boardState[c]
          ) {
            boardWinners[boardIndex] = boardState[a];
            return;
          }
        }
        if (!boardState.includes('')) boardWinners[boardIndex] = 'tie';
      }

      function checkGameWinner() {
        /* ... (same logic) ... */
        if (gameWinner) return;
        const winningCombos = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8],
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8],
          [0, 4, 8],
          [2, 4, 6],
        ];
        for (const combo of winningCombos) {
          const [a, b, c] = combo;
          if (
            boardWinners[a] &&
            boardWinners[a] !== 'tie' &&
            boardWinners[a] === boardWinners[b] &&
            boardWinners[a] === boardWinners[c]
          ) {
            gameWinner = boardWinners[a];
            winningCombination = combo;
            gameActive = false;
            return;
          }
        }
        const allBoardsDecided = boardWinners.every(winner => winner !== '');
        if (allBoardsDecided && !gameWinner) {
          gameWinner = 'tie';
          winningCombination = null;
          gameActive = false;
        }
      }

      function endGame() {
        /* ... (same logic, ensures UI update) ... */
        if (!gameActive && !gameWinner) return; // Avoid double calls unless winner just found
        gameActive = false;
        if (pendingAIMove) clearTimeout(pendingAIMove);
        pendingAIMove = null;
        updateStatusDisplay(aiThinking, '');
        updateOnlinePlayerUI(); // Show no active player
        updateActiveBoards(); // Dim inactive boards

        displayEndGameMessage(); // Sets text based on gameWinner

        if (winningCombination && gameWinner !== 'tie') {
          setTimeout(() => drawSuperWinningLine(winningCombination), 100);
        }

        gameOver.classList.add('show'); // Show the modal

        if (isOnlineGame) {
          quitOnlineBtn.style.display = 'none';
          newGameBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Rematch?'; // Update button text
          settingsBtn.style.display = 'inline-flex';
          // Note: Actual rematch logic not implemented, button currently goes to menu
        } else {
          saveGameState(); // Save final local state
        }
      }

      function displayEndGameMessage(customMessage = '') {
        /* ... (same logic, handles custom messages better) ... */
        let message = '';
        let winnerClass = '';

        if (customMessage) {
          message = customMessage;
          // Try to determine winner class based on the reason if possible
          if (reasonIncludesWin(customMessage)) {
            winnerClass = playerSymbolOnline;
          } else if (reasonIncludesLoss(customMessage)) {
            winnerClass = playerSymbolOnline === 'x' ? 'o' : 'x';
          } else {
            winnerClass = 'tie'; // Default for neutral messages like quit/error
          }
        } else {
          // Standard win/loss/tie messages
          if (gameWinner === 'x') {
            if (isOnlineGame)
              message =
                playerSymbolOnline === 'x' ? 'You Win!' : 'Opponent Wins!';
            else
              message =
                gameSettings.gameMode === 'ai' ? 'You Win!' : 'Player X Wins!';
            winnerClass = 'x';
          } else if (gameWinner === 'o') {
            if (isOnlineGame)
              message =
                playerSymbolOnline === 'o' ? 'You Win!' : 'Opponent Wins!';
            else
              message =
                gameSettings.gameMode === 'ai' ? 'AI Wins!' : 'Player O Wins!';
            winnerClass = 'o';
          } else {
            message = "It's a Tie!";
            winnerClass = 'tie';
          }
        }

        gameOverMessage.textContent = message;
        gameOverMessage.className = `game-over-message ${winnerClass}`;

        playAgainBtn.style.display = isOnlineGame ? 'none' : 'inline-flex'; // Hide for online
        goToMenuBtn.style.display = 'inline-flex'; // Always show menu button
        viewBoardBtn.style.display = 'inline-flex'; // Always show view board
      }
      // Helpers for displayEndGameMessage
      function reasonIncludesWin(reason) {
        return reason.toLowerCase().includes('you win');
      }
      function reasonIncludesLoss(reason) {
        return reason.toLowerCase().includes('you lose');
      }

      // --- Drawing Functions --- (Mostly unchanged)
      function findWinningCombo(boardIndex) {
        /* ... (same) ... */
        if (
          boardWinners[boardIndex] !== 'x' &&
          boardWinners[boardIndex] !== 'o'
        )
          return null;
        const board = boards[boardIndex];
        const combos = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8],
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8],
          [0, 4, 8],
          [2, 4, 6],
        ];
        for (const c of combos)
          if (
            board[c[0]] === boardWinners[boardIndex] &&
            board[c[1]] === boardWinners[boardIndex] &&
            board[c[2]] === boardWinners[boardIndex]
          )
            return c;
        return null;
      }
      function updateBoardUI(boardIndex, winningCombo = null) {
        /* ... (same) ... */
        const boardElement = document.querySelector(
          `.board[data-index="${boardIndex}"]`,
        );
        if (!boardElement) return;
        let boardOpacity = '1';
        boardElement.classList.remove(
          'won-x',
          'won-o',
          'tie',
          'active',
          'inactive-board',
        );
        boardElement.style.backgroundColor = '';
        boardElement.style.borderColor = '';
        boardElement.style.boxShadow = '';
        boardElement.style.animation = '';
        const winner = boardWinners[boardIndex];
        if (winner) {
          boardOpacity = '0.6';
          if (winner === 'x') {
            boardElement.classList.add('won-x');
            boardElement.style.borderColor = gameSettings.xColor;
            boardElement.style.backgroundColor = hexToRGBA(
              gameSettings.xColor,
              0.2,
            );
          } else if (winner === 'o') {
            boardElement.classList.add('won-o');
            boardElement.style.borderColor = gameSettings.oColor;
            boardElement.style.backgroundColor = hexToRGBA(
              gameSettings.oColor,
              0.2,
            );
          } else {
            boardElement.classList.add('tie');
          }
          boardElement.querySelectorAll('.cell').forEach(cell => {
            cell.style.opacity = boardOpacity;
            cell.style.cursor = 'default';
          });
          const existingLine = boardElement.querySelector('.winning-line');
          if (existingLine) existingLine.remove();
          if (winningCombo && (winner === 'x' || winner === 'o')) {
            setTimeout(() => drawWinningLine(boardIndex, winningCombo), 50);
          }
        }
      }
      function drawWinningLine(boardIndex, combo) {
        /* ... (same improved version) ... */
        const boardElement = document.querySelector(
          `.board[data-index="${boardIndex}"]`,
        );
        if (!boardElement || !combo) return;
        const existingLine = boardElement.querySelector('.winning-line');
        if (existingLine) return;
        const bw = boardElement.offsetWidth,
          bh = boardElement.offsetHeight,
          g = 5,
          p = 5;
        const cw = (bw - 2 * p - 2 * g) / 3,
          ch = (bh - 2 * p - 2 * g) / 3;
        const lt = Math.max(2, Math.min(4, Math.round(cw * 0.08)));
        const [a, c] = [combo[0], combo[2]];
        const ac = a % 3,
          ar = Math.floor(a / 3),
          cc = c % 3,
          cr = Math.floor(c / 3);
        const sxC = p + ac * (cw + g) + cw / 2,
          syC = p + ar * (ch + g) + ch / 2,
          exC = p + cc * (cw + g) + cw / 2,
          eyC = p + cr * (ch + g) + ch / 2;
        const ang = Math.atan2(eyC - syC, exC - sxC),
          off = cw * 0.35;
        const sx = sxC - Math.cos(ang) * off,
          sy = syC - Math.sin(ang) * off,
          ex = exC + Math.cos(ang) * off,
          ey = eyC + Math.sin(ang) * off;
        const dx = ex - sx,
          dy = ey - sy,
          len = Math.sqrt(dx * dx + dy * dy);
        const line = document.createElement('div');
        line.className = 'winning-line';
        line.style.width = `${len}px`;
        line.style.height = `${lt}px`;
        line.style.left = `${sx}px`;
        line.style.top = `${sy - lt / 2}px`;
        line.style.transform = `rotate(${ang}rad)`;
        line.style.transformOrigin = `0 ${lt / 2}px`;
        line.style.backgroundColor =
          boardWinners[boardIndex] === 'x'
            ? gameSettings.xColor
            : gameSettings.oColor;
        line.style.borderRadius = `${lt / 2}px`;
        boardElement.appendChild(line);
      }
      function drawSuperWinningLine(combo) {
        /* ... (same improved version) ... */
        const existingLine = superBoard.querySelector(
          '.winning-line:not([data-board-index])',
        );
        if (existingLine) return;
        const [a, c] = [combo[0], combo[2]];
        const bA = document.querySelector(`.board[data-index="${a}"]`),
          bC = document.querySelector(`.board[data-index="${c}"]`);
        if (!bA || !bC) return;
        const sbr = superBoard.getBoundingClientRect(),
          ar = bA.getBoundingClientRect(),
          cr = bC.getBoundingClientRect();
        const sxC = (ar.left + ar.right) / 2 - sbr.left,
          syC = (ar.top + ar.bottom) / 2 - sbr.top,
          exC = (cr.left + cr.right) / 2 - sbr.left,
          eyC = (cr.top + cr.bottom) / 2 - sbr.top;
        const ang = Math.atan2(eyC - syC, exC - sxC),
          bs = sbr.width / 3,
          off = bs * 0.4;
        const sx = sxC - Math.cos(ang) * off,
          sy = syC - Math.sin(ang) * off,
          ex = exC + Math.cos(ang) * off,
          ey = eyC + Math.sin(ang) * off;
        const dx = ex - sx,
          dy = ey - sy,
          len = Math.sqrt(dx * dx + dy * dy);
        const lt = Math.max(6, Math.min(10, Math.round(bs * 0.08)));
        const line = document.createElement('div');
        line.className = 'winning-line';
        line.style.width = `${len}px`;
        line.style.height = `${lt}px`;
        line.style.left = `${sx}px`;
        line.style.top = `${sy - lt / 2}px`;
        line.style.transform = `rotate(${ang}rad)`;
        line.style.transformOrigin = `0 ${lt / 2}px`;
        line.style.backgroundColor =
          gameWinner === 'x' ? gameSettings.xColor : gameSettings.oColor;
        line.style.zIndex = '10';
        line.style.borderRadius = `${lt / 2}px`;
        superBoard.appendChild(line);
      }
      function findAndHighlightLastMove() {
        /* ... (same) ... */
        document
          .querySelectorAll('.cell.last-move')
          .forEach(c => c.classList.remove('last-move'));
        if (
          lastMove &&
          lastMove.boardIndex !== -1 &&
          lastMove.cellIndex !== -1
        ) {
          const lc = document.querySelector(
            `.cell[data-board="${lastMove.boardIndex}"][data-cell="${lastMove.cellIndex}"]`,
          );
          if (lc) lc.classList.add('last-move');
        }
      }

      // --- AI Logic --- (Unchanged from previous version)
      function findBestMove(boardIndex) {
        /* ... (same) ... */
        const b = boards[boardIndex];
        const av = [];
        for (let i = 0; i < 9; i++) if (b[i] === '') av.push(i);
        if (av.length === 0) return -1;
        for (const ci of av) {
          const t = [...b];
          t[ci] = 'o';
          if (checkTempBoardWinner(t) === 'o') return ci;
        }
        if (gameSettings.difficulty !== 'easy') {
          for (const ci of av) {
            const t = [...b];
            t[ci] = 'x';
            if (checkTempBoardWinner(t) === 'x') return ci;
          }
        }
        if (gameSettings.difficulty !== 'easy') {
          const c = 4;
          if (av.includes(c)) return c;
          const cn = [0, 2, 6, 8].filter(c => av.includes(c));
          if (cn.length > 0) return cn[Math.floor(Math.random() * cn.length)];
          const s = [1, 3, 5, 7].filter(s => av.includes(s));
          if (s.length > 0) return s[Math.floor(Math.random() * s.length)];
        }
        return av[Math.floor(Math.random() * av.length)];
      }
      function checkTempBoardWinner(boardState) {
        /* ... (same) ... */
        const wc = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8],
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8],
          [0, 4, 8],
          [2, 4, 6],
        ];
        for (const c of wc) {
          const [a, b, d] = c;
          if (
            boardState[a] &&
            boardState[a] === boardState[b] &&
            boardState[a] === boardState[d]
          )
            return boardState[a];
        }
        return boardState.includes('') ? '' : 'tie';
      }
      function aiMakeMove() {
        /* ... (same) ... */
        if (!gameActive || gameWinner || currentPlayer !== 'o' || isOnlineGame)
          return;
        updateStatusDisplay(aiThinking, '', false);
        let bi, ci;
        const hard = gameSettings.difficulty === 'hard';
        const any = activeBoard === null || boardWinners[activeBoard] !== '';
        let targets = [];
        if (any)
          boardWinners.forEach((w, i) => {
            if (w === '') targets.push(i);
          });
        else targets.push(activeBoard);
        if (targets.length === 0) return;
        if (hard) {
          let bestS = -Infinity;
          let bestM = [];
          for (const b of targets) {
            for (let c = 0; c < 9; c++) {
              if (boards[b][c] === '') {
                const s = scoreMove(b, c, 'o');
                if (s > bestS) {
                  bestS = s;
                  bestM = [{ b, c }];
                } else if (s === bestS) {
                  bestM.push({ b, c });
                }
              }
            }
          }
          if (bestM.length > 0) {
            const ch = bestM[Math.floor(Math.random() * bestM.length)];
            bi = ch.b;
            ci = ch.c;
          } else {
            bi = targets[Math.floor(Math.random() * targets.length)];
            ci = findBestMove(bi);
          }
        } else {
          let found = false;
          for (const b of targets) {
            const wc = findWinningCell(b, 'o');
            if (wc !== -1) {
              bi = b;
              ci = wc;
              found = true;
              break;
            }
          }
          if (!found && gameSettings.difficulty !== 'easy') {
            for (const b of targets) {
              const bc = findWinningCell(b, 'x');
              if (bc !== -1) {
                bi = b;
                ci = bc;
                found = true;
                break;
              }
            }
          }
          if (!found) {
            if (targets.length === 1) {
              bi = targets[0];
              ci = findBestMove(bi);
            } else {
              bi = targets[Math.floor(Math.random() * targets.length)];
              ci = findBestMove(bi);
            }
          }
        }
        if (
          typeof bi !== 'undefined' &&
          typeof ci !== 'undefined' &&
          ci !== -1 &&
          boards[bi]?.[ci] === ''
        ) {
          makeMove(bi, ci, 'o');
        } else {
          console.error('AI Fail', { bi, ci, activeBoard, targets });
          let fb = false;
          for (let b = 0; b < 9; b++) {
            if (boardWinners[b] === '') {
              for (let c = 0; c < 9; c++) {
                if (boards[b][c] === '') {
                  makeMove(b, c, 'o');
                  fb = true;
                  break;
                }
              }
            }
            if (fb) break;
          }
          if (!fb) console.error('AI FALLBACK FAIL');
        }
      }
      function findWinningCell(boardIndex, player) {
        /* ... (same) ... */
        const b = boards[boardIndex];
        for (let i = 0; i < 9; i++) {
          if (b[i] === '') {
            const t = [...b];
            t[i] = player;
            if (checkTempBoardWinner(t) === player) return i;
          }
        }
        return -1;
      }
      function doesMoveWinSuperBoard(b, c, p) {
        /* ... (same) ... */ const tw = [...boardWinners];
        tw[b] = p;
        return checkSuperBoardWin(tw) !== null;
      }
      function checkSuperBoardWin(bw) {
        /* ... (same) ... */ const wc = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8],
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8],
          [0, 4, 8],
          [2, 4, 6],
        ];
        for (const c of wc) {
          const [a, b, d] = c;
          if (bw[a] && bw[a] !== 'tie' && bw[a] === bw[b] && bw[a] === bw[d])
            return c;
        }
        return null;
      }
      function scoreMove(bi, ci, p) {
        /* ... (same strategy, maybe simplified) ... */
        const o = p === 'x' ? 'o' : 'x';
        let s = 0;
        const tb = [...boards[bi]];
        tb[ci] = p;
        const r = checkTempBoardWinner(tb);
        const tob = [...boards[bi]];
        tob[ci] = o;
        const obr = checkTempBoardWinner(tob);
        if (r === p) {
          s += 1000;
          if (doesMoveWinSuperBoard(bi, ci, p)) s += 10000;
        }
        if (obr === o) {
          s += 800;
          const tow = [...boardWinners];
          tow[bi] = o;
          if (checkSuperBoardWin(tow)) s += 9000;
        }
        if (ci === 4) s += 30;
        else if ([0, 2, 6, 8].includes(ci)) s += 15;
        else s += 5;
        const tbi = ci;
        if (gameSettings.rules === 'standard' && boardWinners[tbi] === '') {
          if (findWinningCell(tbi, o) !== -1) s -= 500;
          if (findWinningCell(tbi, p) !== -1) s += 100;
        } else if (
          gameSettings.rules === 'standard' &&
          boardWinners[tbi] !== ''
        )
          s += 10;
        s += Math.random();
        return s;
      }

      // --- Settings Modal Logic ---
      function showSettings() {
        /* ... (same as before) ... */
        if (isOnlineGame) return;
        // Remove AIvsAI option if dynamically added previously (should be removed from HTML ideally)
        document.getElementById('aiVsAi')?.closest('.setting-option')?.remove();

        if (!['human', 'ai'].includes(gameSettings.gameMode))
          gameSettings.gameMode = 'ai';
        document.querySelector(
          `input[name="gameMode"][value="${gameSettings.gameMode}"]`,
        ).checked = true;
        document.querySelector(
          `input[name="rules"][value="${gameSettings.rules}"]`,
        ).checked = true;
        document.querySelector(
          `input[name="difficulty"][value="${gameSettings.difficulty}"]`,
        ).checked = true;
        xColorPicker.value = gameSettings.xColor;
        oColorPicker.value = gameSettings.oColor;
        xColorPicker.style.backgroundColor = gameSettings.xColor;
        oColorPicker.style.backgroundColor = gameSettings.oColor;
        aiDifficultyGroup.style.display =
          gameSettings.gameMode === 'human' ? 'none' : 'block';
        tempXColor = gameSettings.xColor;
        tempOColor = gameSettings.oColor;
        showModal(settingsModal);
      }
      function hideSettings() {
        /* ... (same as before) ... */
        if (xColorPicker) {
          xColorPicker.value = gameSettings.xColor;
          xColorPicker.style.backgroundColor = gameSettings.xColor;
        }
        if (oColorPicker) {
          oColorPicker.value = gameSettings.oColor;
          oColorPicker.style.backgroundColor = gameSettings.oColor;
        }
        hideModal(settingsModal);
      }
      function saveGameSettings() {
        /* ... (same as before) ... */
        let selMode = document.querySelector(
          'input[name="gameMode"]:checked',
        )?.value;
        if (!['human', 'ai'].includes(selMode)) selMode = 'ai';
        const selRules = document.querySelector(
          'input[name="rules"]:checked',
        ).value;
        const selDiff = document.querySelector(
          'input[name="difficulty"]:checked',
        ).value;
        const selX = tempXColor,
          selO = tempOColor;
        const prevMode = gameSettings.gameMode,
          prevRules = gameSettings.rules;
        gameSettings = {
          gameMode: selMode,
          rules: selRules,
          difficulty: selDiff,
          xColor: selX,
          oColor: selO,
        };
        updateColors();
        hideSettings();
        localStorage.setItem(
          'ticTacSquaredPreferences',
          JSON.stringify(gameSettings),
        );
        if (gameActive && !isOnlineGame && !gameWinner) {
          if (prevRules !== selRules) {
            if (selRules === 'free') activeBoard = null;
            else if (lastMove.cellIndex !== -1)
              activeBoard =
                boardWinners[lastMove.cellIndex] === ''
                  ? lastMove.cellIndex
                  : null;
            updateActiveBoards();
          }
          if (prevMode !== selMode) {
            updateOnlinePlayerUI();
            if (
              prevMode === 'human' &&
              selMode === 'ai' &&
              currentPlayer === 'o'
            ) {
              updateStatusDisplay(aiThinking, 'AI thinking...', true);
              if (pendingAIMove) clearTimeout(pendingAIMove);
              pendingAIMove = setTimeout(() => {
                pendingAIMove = null;
                if (!gameActive || gameWinner) {
                  updateStatusDisplay(aiThinking, '');
                  return;
                }
                aiMakeMove();
              }, 800);
            } else if (prevMode === 'ai' && selMode === 'human') {
              if (pendingAIMove) clearTimeout(pendingAIMove);
              pendingAIMove = null;
              updateStatusDisplay(aiThinking, '');
            }
          }
        } else if (!gameActive && !isOnlineGame) {
        }
        saveGameState(); // Save potentially updated state if game was active
      }
      let tempXColor;
      let tempOColor; // Temp storage for color picker preview
      xColorPicker.addEventListener('input', e => {
        tempXColor = e.target.value;
        xColorPicker.style.backgroundColor = tempXColor;
      });
      oColorPicker.addEventListener('input', e => {
        tempOColor = e.target.value;
        oColorPicker.style.backgroundColor = tempOColor;
      });

      // --- How To Play Modal ---
      function showHowToPlay() {
        showModal(howToPlayModal);
      }
      function hideHowToPlay() {
        hideModal(howToPlayModal);
      }

      // --- Local Storage --- (Only for local games and preferences)
      function saveGameState() {
        /* ... (same as before) ... */
        if (isOnlineGame) return;
        const state = {
          currentPlayer,
          activeBoard,
          boards,
          boardWinners,
          gameWinner,
          gameActive,
          winningCombination,
          lastMove,
          savedGameSettings: {
            gameMode: gameSettings.gameMode,
            rules: gameSettings.rules,
            difficulty: gameSettings.difficulty,
          },
        };
        localStorage.setItem('ticTacSquaredState', JSON.stringify(state));
        console.log('Local game saved.');
      }
      function loadGameState() {
        /* ... (same as before) ... */
        if (isOnlineGame) return false;
        try {
          const saved = localStorage.getItem('ticTacSquaredState');
          if (!saved) return false;
          const gs = JSON.parse(saved);
          currentPlayer = gs.currentPlayer;
          activeBoard = gs.activeBoard;
          boards = gs.boards;
          boardWinners = gs.boardWinners;
          gameWinner = gs.gameWinner;
          gameActive = gs.gameActive;
          winningCombination = gs.winningCombination;
          lastMove = gs.lastMove || {
            boardIndex: -1,
            cellIndex: -1,
            player: '',
          };
          if (gs.savedGameSettings) {
            gameSettings.gameMode = gs.savedGameSettings.gameMode;
            gameSettings.rules = gs.savedGameSettings.rules;
            gameSettings.difficulty = gs.savedGameSettings.difficulty;
          } else {
            loadPreferences();
          }
          loadPreferences();
          updateColors(); // Load current color prefs regardless
          gameModeType = 'local';
          isOnlineGame = false;
          hideModal(startMenuModal);
          hideModal(onlineMenuModal);
          hideModal(coinFlipModal);
          recreateGameUI();
          if (
            gameActive &&
            !gameWinner &&
            gameSettings.gameMode === 'ai' &&
            currentPlayer === 'o'
          ) {
            updateStatusDisplay(aiThinking, 'AI thinking...', true);
            if (pendingAIMove) clearTimeout(pendingAIMove);
            pendingAIMove = setTimeout(() => {
              pendingAIMove = null;
              if (!gameActive || gameWinner) {
                updateStatusDisplay(aiThinking, '');
                return;
              }
              aiMakeMove();
            }, 800);
          }
          console.log('Loaded local game.');
          return true;
        } catch (e) {
          console.error('Load game error:', e);
          localStorage.removeItem('ticTacSquaredState');
          return false;
        }
      }
      function clearSavedGameState() {
        /* ... (same) ... */ localStorage.removeItem('ticTacSquaredState');
        console.log('Cleared local save.');
      }
      function loadPreferences() {
        /* ... (same as before, ensures defaults) ... */
        const sp = localStorage.getItem('ticTacSquaredPreferences');
        let prefs = {};
        if (sp) {
          try {
            prefs = JSON.parse(sp);
          } catch (e) {
            console.error('Pref load error', e);
            localStorage.removeItem('ticTacSquaredPreferences');
          }
        }
        gameSettings.gameMode = ['human', 'ai'].includes(prefs.gameMode)
          ? prefs.gameMode
          : 'ai';
        gameSettings.rules = ['standard', 'free'].includes(prefs.rules)
          ? prefs.rules
          : 'standard';
        gameSettings.difficulty = ['easy', 'medium', 'hard'].includes(
          prefs.difficulty,
        )
          ? prefs.difficulty
          : 'medium';
        gameSettings.xColor = prefs.xColor || DEFAULT_X_COLOR;
        gameSettings.oColor = prefs.oColor || DEFAULT_O_COLOR;
        updateColors();
      }

      // --- Coin Flip --- (Only for local games)
      function flipCoin() {
        /* ... (same as before) ... */
        if (isOnlineGame) return;
        coin.classList.remove('flipping');
        coin.style.transform = '';
        coinResult.textContent = '';
        void coin.offsetWidth;
        const r = Math.random(),
          w = r < 0.5 ? 'x' : 'o';
        coin.classList.add('flipping');
        setTimeout(() => {
          coin.classList.remove('flipping');
          coin.style.transform =
            w === 'x'
              ? 'rotateY(0deg) rotateX(0deg)'
              : 'rotateY(180deg) rotateX(0deg)';
          coinResult.innerHTML = `<span style="color:${w === 'x' ? gameSettings.xColor : gameSettings.oColor};font-weight:bold;">${w.toUpperCase()} goes first!</span>`;
          setTimeout(() => {
            hideModal(coinFlipModal);
            startGame(w);
          }, 1500);
        }, 1500);
      }

      // --- Event Listeners Setup ---
      function setupEventListeners() {
        // Menu Buttons
        playLocallyBtn.addEventListener('click', () => {
          const savedState = localStorage.getItem('ticTacSquaredState');
          if (
            savedState &&
            confirm('Continue previous local game? (Cancel for new game)')
          ) {
            if (!loadGameState()) {
              clearSavedGameState();
              initLocalGame();
            }
          } else {
            clearSavedGameState();
            initLocalGame();
          }
        });
        playOnlineBtn.addEventListener('click', initOnlineMode);
        closeOnlineMenuBtn.addEventListener('click', showStartMenu);
        createGameBtn.addEventListener('click', () => createOnlineGame(false)); // Pass false for non-retry
        joinGameBtn.addEventListener('click', joinOnlineGame);
        gameCodeInput.addEventListener('input', () => {
          gameCodeInput.value = gameCodeInput.value
            .toUpperCase()
            .replace(/[^A-Z1-9]/g, '');
        }); // Force uppercase, allowed chars
        gameCodeInput.addEventListener('keypress', e => {
          if (e.key === 'Enter') joinGameBtn.click();
        });
        gameCodeDisplay.addEventListener('click', () => {
          if (shortGameCode) copyToClipboard(shortGameCode);
        });

        // In-Game Controls
        howToPlayBtn.addEventListener('click', showHowToPlay);
        settingsBtn.addEventListener('click', showSettings);
        newGameBtn.addEventListener('click', () => {
          if (isOnlineGame) {
            // Online "New Game" could mean Rematch request or just go to menu
            // Simple: Go back to main menu, requiring new connection
            if (
              confirm(
                'Start a new game? This will end the current online session.',
              )
            ) {
              sendData({ type: 'quit' }); // Inform opponent (optional, cleanup handles disconnect)
              handleDisconnection('Started new game'); // Handle locally
              showStartMenu();
            }
          } else {
            // Local mode
            if (gameActive || gameOver.classList.contains('show')) {
              if (confirm('Start a new local game?')) {
                clearSavedGameState();
                initLocalGame();
              }
            } else {
              initLocalGame();
            } // No game active, just start
          }
        });
        quitOnlineBtn.addEventListener('click', () => {
          if (
            isOnlineGame &&
            confirm('Quit the online game? Your opponent will win.')
          ) {
            sendData({ type: 'quit' });
            handleDisconnection('You quit the game.');
            showStartMenu();
          }
        });

        // Game Over Controls
        playAgainBtn.addEventListener('click', () => {
          if (!isOnlineGame) {
            clearSavedGameState();
            initLocalGame();
          }
        });
        viewBoardBtn.addEventListener('click', () => hideModal(gameOver));
        goToMenuBtn.addEventListener('click', showStartMenu);

        // Settings Controls
        saveSettings.addEventListener('click', saveGameSettings);
        cancelSettings.addEventListener('click', hideSettings); // Now in header
        resetXColorBtn.addEventListener('click', e => {
          e.preventDefault();
          xColorPicker.value = DEFAULT_X_COLOR;
          xColorPicker.dispatchEvent(new Event('input'));
        });
        resetOColorBtn.addEventListener('click', e => {
          e.preventDefault();
          oColorPicker.value = DEFAULT_O_COLOR;
          oColorPicker.dispatchEvent(new Event('input'));
        });
        humanVsHumanRadio.addEventListener('change', () => {
          aiDifficultyGroup.style.display = 'none';
        });
        humanVsAIRadio.addEventListener('change', () => {
          aiDifficultyGroup.style.display = 'block';
        });

        // How to Play Close
        closeHowToPlayBtn.addEventListener('click', hideHowToPlay);

        // Modal Outside Click Listeners (Refined)
        [
          startMenuModal,
          onlineMenuModal,
          settingsModal,
          howToPlayModal,
          coinFlipModal,
          gameOver,
        ].forEach(modal => {
          if (modal) {
            modal.addEventListener('click', event => {
              if (event.target === modal) {
                // Clicked on the backdrop
                if (modal === onlineMenuModal) closeOnlineMenuBtn.click();
                else if (modal === settingsModal) cancelSettings.click();
                else if (modal === howToPlayModal) closeHowToPlayBtn.click();
                else if (modal === gameOver) viewBoardBtn.click(); // Same as view board
                // Don't close startMenuModal or coinFlipModal by clicking outside
              }
            });
          }
        });

        // Handle user leaving the page during an online game
        window.addEventListener('beforeunload', event => {
          if (isOnlineGame && conn && conn.open) {
            // Standard way to notify opponent is tricky with beforeunload
            // Best effort: try sending a quick quit message
            // Note: This is not guaranteed to be sent reliably
            sendData({ type: 'quit' });
            // Don't prevent unload, just try to notify
          }
        });
      }

      // --- Initial Load ---
      document.addEventListener('DOMContentLoaded', () => {
        setupEventListeners();
        showStartMenu(); // Always start at the main menu
      });
    </script>
  </body>
</html>
